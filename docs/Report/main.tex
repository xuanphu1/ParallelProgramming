\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[vietnamese]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=2.5cm}

% Cấu hình cho code listings
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    showstringspaces=false
}

\title{BÁO CÁO ĐỒ ÁN\\
Tối Ưu Hóa Song Song Bộ Lọc Sobel\\
Trong Hệ Thống Nhận Dạng Biển Số Xe\\
Sử Dụng Mô Hình Học Sâu}
\author{Sinh viên thực hiện}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\listoffigures
\listoftables

\newpage

\chapter{GIỚI THIỆU}

\section{Đặt vấn đề}

\subsection{Bài toán}

Trong thời đại công nghệ hiện đại, việc nhận dạng biển số xe tự động đóng vai trò quan trọng trong nhiều ứng dụng thực tế:

\textbf{Giám sát giao thông:} Hệ thống nhận dạng biển số giúp tự động hóa việc giám sát và quản lý phương tiện giao thông, phát hiện vi phạm, kiểm soát tốc độ và quản lý lưu lượng giao thông.

\textbf{Bãi giữ xe thông minh:} Tự động hóa quá trình vào/ra của xe, tính phí, quản lý chỗ đỗ xe mà không cần nhân viên canh gác.

\textbf{Nhận dạng phương tiện tự động:} Ứng dụng trong hệ thống thu phí điện tử, kiểm soát an ninh, và quản lý đội xe.

\subsection{Khó khăn}

Tuy nhiên, việc nhận dạng biển số xe trong môi trường thực tế gặp nhiều thách thức:

\textbf{Nhiễu ảnh:} Ảnh có thể bị nhiễu do điều kiện thời tiết, chất lượng camera, hoặc khoảng cách chụp.

\textbf{Ánh sáng thay đổi:} Điều kiện ánh sáng thay đổi liên tục (ban ngày, ban đêm, bóng râm) ảnh hưởng đến chất lượng nhận dạng.

\textbf{Ảnh độ phân giải thấp:} Camera đặt xa hoặc chất lượng thấp dẫn đến ảnh mờ, khó nhận dạng.

\textbf{Tốc độ xử lý real-time:} Yêu cầu xử lý nhanh để đáp ứng ứng dụng thời gian thực, đặc biệt trong video streaming.

\section{Mục tiêu đề tài}

Đề tài tập trung vào việc tối ưu hóa pipeline nhận dạng biển số xe thông qua các mục tiêu cụ thể:

\subsection{Áp dụng bộ lọc Sobel}

\textbf{Làm nổi biên:} Sử dụng bộ lọc Sobel để phát hiện và làm nổi bật các cạnh trong ảnh, giúp tăng cường thông tin biên của biển số xe.

\textbf{Giảm nhiễu không cần thiết:} Bộ lọc Sobel giúp loại bỏ các chi tiết không liên quan, tập trung vào các đặc trưng quan trọng của biển số.

\subsection{Song song hóa Sobel}

Để đạt được tốc độ xử lý cao, đề tài triển khai song song hóa bộ lọc Sobel theo nhiều phương pháp:

\textbf{CPU đa luồng:} Sử dụng OpenMP để chia nhỏ ảnh và xử lý song song trên nhiều lõi CPU.

\textbf{GPU:} Triển khai kernel CUDA để tận dụng sức mạnh tính toán song song của GPU.

\textbf{Vector hóa:} Sử dụng SIMD (AVX-256) để xử lý nhiều pixel cùng lúc trong một lệnh CPU.

\subsection{Kết hợp model học sâu}

\textbf{Phát hiện biển số chính xác hơn:} Sử dụng mô hình YOLOv5 để phát hiện vùng biển số với độ chính xác cao.

\textbf{Giảm thời gian suy luận:} Tối ưu pipeline để giảm latency và tăng throughput, đáp ứng yêu cầu real-time.

\section{Phạm vi nghiên cứu}

Đề tài tập trung vào các phạm vi sau:

\textbf{Ảnh tĩnh và video:} Hệ thống có thể xử lý cả ảnh đơn lẻ và luồng video từ camera.

\textbf{Tiền xử lý với Sobel:} Nghiên cứu ảnh hưởng của bộ lọc Sobel đến hiệu suất nhận dạng, không đi sâu vào phần OCR (chỉ sử dụng model OCR có sẵn).

\textbf{So sánh hiệu năng:} So sánh hiệu suất giữa pipeline có và không có bộ lọc Sobel, cũng như so sánh các phương pháp song song hóa khác nhau.

\section{Đóng góp của đề tài}

Đề tài đóng góp các điểm sau:

\textbf{Đề xuất pipeline tiền xử lý song song:} Thiết kế và triển khai pipeline xử lý ảnh song song với nhiều tầng tối ưu (SIMD, OpenMP, CUDA).

\textbf{Đánh giá ảnh hưởng Sobel tới model:} Phân tích và đánh giá tác động của bộ lọc Sobel đến độ chính xác và tốc độ của mô hình học sâu.

\textbf{So sánh hiệu năng:} Cung cấp benchmark chi tiết so sánh các phương pháp song song hóa (CPU scalar, SIMD, CUDA) về FPS và latency.

\chapter{CƠ SỞ LÝ THUYẾT}

\section{Tổng quan xử lý ảnh số}

\subsection{Khái niệm cơ bản}

\textbf{Pixel:} Pixel (picture element) là đơn vị nhỏ nhất của ảnh số, mỗi pixel chứa thông tin về màu sắc và độ sáng tại một vị trí cụ thể.

\textbf{Kernel:} Kernel (hay filter) là một ma trận nhỏ được sử dụng để thực hiện các phép toán convolution trên ảnh, thường có kích thước 3x3, 5x5, hoặc lớn hơn.

\textbf{Convolution:} Convolution là phép toán cơ bản trong xử lý ảnh, trong đó kernel được "trượt" qua ảnh để tính giá trị mới cho mỗi pixel dựa trên các pixel xung quanh.

\subsection{Lọc không gian (Spatial Filtering)}

Lọc không gian là kỹ thuật xử lý ảnh trực tiếp trên miền không gian (spatial domain), thay vì chuyển sang miền tần số. Có hai loại chính:

\textbf{Lọc tuyến tính:} Sử dụng convolution với kernel tuyến tính, ví dụ: Gaussian blur, Sobel, Laplacian.

\textbf{Lọc phi tuyến:} Sử dụng các phép toán phi tuyến, ví dụ: median filter, morphological operations.

\section{Bộ lọc Sobel}

\subsection{Nguyên lý phát hiện biên}

Bộ lọc Sobel là một toán tử gradient được sử dụng để phát hiện biên trong ảnh. Nguyên lý hoạt động dựa trên việc tính gradient (độ dốc) của cường độ pixel:

\begin{equation}
G = \sqrt{G_x^2 + G_y^2}
\end{equation}

Trong đó $G_x$ và $G_y$ là gradient theo hướng ngang và dọc.

\subsection{Kernel Sobel}

Bộ lọc Sobel sử dụng hai kernel riêng biệt để tính gradient theo hai hướng:

\textbf{Kernel Gx (gradient ngang):}
\begin{equation}
G_x = \begin{bmatrix}
-1 & 0 & 1 \\
-2 & 0 & 2 \\
-1 & 0 & 1
\end{bmatrix}
\end{equation}

\textbf{Kernel Gy (gradient dọc):}
\begin{equation}
G_y = \begin{bmatrix}
-1 & -2 & -1 \\
0 & 0 & 0 \\
1 & 2 & 1
\end{bmatrix}
\end{equation}

\subsection{Đặc điểm}

\textbf{Nhấn mạnh biên:} Sobel làm nổi bật các vùng có sự thay đổi đột ngột về cường độ, đặc biệt hiệu quả với biên dọc và ngang.

\textbf{Nhạy với nhiễu:} Do tính chất gradient, Sobel có thể nhạy cảm với nhiễu trong ảnh. Có thể kết hợp với Gaussian blur để giảm nhiễu trước khi áp dụng Sobel.

\section{Song song trong xử lý ảnh}

\subsection{Tính chất}

Xử lý ảnh có tính chất song song tự nhiên:

\textbf{Mỗi pixel xử lý độc lập:} Trong nhiều phép toán xử lý ảnh (như Sobel), việc tính toán giá trị pixel mới chỉ phụ thuộc vào các pixel lân cận, không phụ thuộc vào kết quả của các pixel khác. Điều này cho phép xử lý song song hiệu quả.

\subsection{Các mô hình song song}

\textbf{CPU đa luồng (OpenMP, Threading):} Chia ảnh thành các vùng và gán mỗi vùng cho một thread xử lý. OpenMP cung cấp các directive đơn giản để song song hóa vòng lặp.

\textbf{GPU (CUDA / OpenCL):} Tận dụng hàng nghìn lõi tính toán của GPU để xử lý song song ở mức độ hạt mịn (fine-grained parallelism). Mỗi thread GPU có thể xử lý một hoặc một nhóm pixel nhỏ.

\textbf{SIMD / Vectorization:} Sử dụng các lệnh vector của CPU (AVX, SSE) để xử lý nhiều pixel cùng lúc trong một lệnh. Ví dụ: AVX-256 có thể xử lý 8 giá trị float (32-bit) cùng lúc.

\section{Bài toán phát hiện biển số xe}

\subsection{Object Detection}

Phát hiện biển số xe là một bài toán object detection, yêu cầu:
\begin{itemize}
    \item Xác định vị trí biển số trong ảnh (bounding box)
    \item Phân loại đối tượng (có phải biển số hay không)
    \item Xử lý trường hợp có nhiều biển số trong một ảnh
\end{itemize}

\subsection{Các hướng tiếp cận}

\textbf{Truyền thống:} 
\begin{itemize}
    \item Haar Cascade: Sử dụng đặc trưng Haar và AdaBoost
    \item Edge-based: Dựa trên phát hiện biên và hình dạng hình học
    \item Template matching: So khớp với mẫu biển số
\end{itemize}

\textbf{Học sâu:}
\begin{itemize}
    \item YOLO (You Only Look Once): Phát hiện đối tượng trong một lần duyệt qua mạng, nhanh và hiệu quả
    \item SSD (Single Shot Detector): Tương tự YOLO, sử dụng nhiều scale
    \item Faster R-CNN: Chính xác hơn nhưng chậm hơn, sử dụng region proposal
\end{itemize}

\section{Mô hình học sâu sử dụng}

\subsection{Kiến trúc tổng quan}

Đề tài sử dụng YOLOv5 (nano variant) cho cả detection và OCR:

\textbf{YOLOv5 Architecture:}
\begin{itemize}
    \item Backbone: CSPDarknet53 (Cross Stage Partial Network)
    \item Neck: PANet (Path Aggregation Network)
    \item Head: Detection head với anchor-based detection
\end{itemize}

\subsection{Đầu vào / Đầu ra}

\textbf{Detection Model:}
\begin{itemize}
    \item Input: Ảnh RGB kích thước 640x640 pixels
    \item Output: Bounding boxes với confidence scores và class IDs
    \item Format: ONNX (Open Neural Network Exchange)
\end{itemize}

\textbf{OCR Model:}
\begin{itemize}
    \item Input: Ảnh ROI biển số đã cắt, kích thước 320x320 pixels
    \item Output: Các ký tự được nhận dạng với confidence scores
\end{itemize}

\subsection{Loss function}

YOLOv5 sử dụng loss function kết hợp:
\begin{equation}
L_{total} = L_{box} + L_{obj} + L_{cls}
\end{equation}

Trong đó:
\begin{itemize}
    \item $L_{box}$: Loss cho bounding box regression (IoU loss)
    \item $L_{obj}$: Loss cho objectness (có đối tượng hay không)
    \item $L_{cls}$: Loss cho classification
\end{itemize}

\subsection{Ưu điểm và hạn chế}

\textbf{Ưu điểm:}
\begin{itemize}
    \item Tốc độ suy luận nhanh, phù hợp real-time
    \item Độ chính xác cao với model đã được huấn luyện tốt
    \item Hỗ trợ ONNX Runtime, dễ tích hợp vào C++
\end{itemize}

\textbf{Hạn chế:}
\begin{itemize}
    \item Yêu cầu tài nguyên tính toán (GPU khuyến nghị)
    \item Cần dataset lớn và đa dạng để huấn luyện
    \item Nhạy cảm với điều kiện ánh sáng và góc chụp
\end{itemize}

\chapter{PHƯƠNG PHÁP ĐỀ XUẤT}

\section{Tổng quan hệ thống}

\subsection{Pipeline xử lý}

Hệ thống được thiết kế theo kiến trúc pipeline đa tầng với các giai đoạn xử lý tuần tự:

\begin{enumerate}
    \item \textbf{Ảnh gốc:} Nhận ảnh đầu vào từ camera hoặc file
    \item \textbf{Sobel song song:} Áp dụng bộ lọc Sobel với tối ưu song song (SIMD/OpenMP/CUDA)
    \item \textbf{Ảnh tăng cường biên:} Kết quả Sobel được sử dụng để tăng cường thông tin biên
    \item \textbf{Model phát hiện biển số:} YOLOv5 phát hiện vùng biển số từ ảnh đã xử lý
    \item \textbf{Kết quả bounding box:} Trả về tọa độ và confidence của các biển số phát hiện được
    \item \textbf{OCR (tùy chọn):} Nhận dạng ký tự từ các vùng biển số đã phát hiện
\end{enumerate}

\subsection{Sơ đồ khối}

Pipeline được triển khai với 5 threads độc lập (Task Parallelism):

\begin{verbatim}
+-------------+
|  Capture    | -> qCapture_ (5 frames)
+------+------+
       |
+------v------+
|   Sobel     | -> qSobel_ (5 frames)
| (SIMD/GPU)  |
+------+------+
       |
+------v------+
|  Detection  | -> qDetect_ (5 frames)
+------+------+
       |
+------v------+
|    OCR      | -> qOCR_ (5 frames)
| (Multi-ROI) |
+------+------+
       |
+------v------+
|   Render    |
+-------------+
\end{verbatim}

\section{Sobel song song}

\subsection{Cách chia ảnh}

Để tối ưu song song hóa, ảnh được chia theo các chiến lược:

\textbf{Theo dòng:} Chia ảnh thành các dòng và gán mỗi dòng cho một thread (OpenMP):
\begin{lstlisting}
#pragma omp parallel for
for (int y = 1; y < rows - 1; ++y) {
    // Xử lý dòng y
}
\end{lstlisting}

\textbf{Theo block:} Chia ảnh thành các block 2D (ví dụ 64x64 pixels) và xử lý song song các block (có thể mở rộng trong tương lai).

\subsection{Chiến lược song song}

\textbf{Multi-thread CPU:} Sử dụng OpenMP để tự động phân phối công việc cho các lõi CPU có sẵn. Mỗi thread xử lý một phần của ảnh độc lập.

\textbf{GPU kernel:} Triển khai CUDA kernel với mỗi thread xử lý một pixel hoặc một nhóm pixel nhỏ. Sử dụng shared memory để tối ưu truy cập dữ liệu.

\textbf{SIMD vectorization:} Sử dụng AVX-256 intrinsics để xử lý 8 pixels cùng lúc trong mỗi thread, kết hợp với OpenMP để song song hóa theo dòng.

\subsection{Pseudocode Sobel song song}

\begin{lstlisting}
// Sobel với SIMD + OpenMP
function sobelSIMD(src, dst):
    rows = src.rows
    cols = src.cols
    
    #pragma omp parallel for
    for y = 1 to rows-2:
        for x = 1 to cols-9:  // Xử lý 8 pixels cùng lúc
            // Load 8 pixels từ 3 dòng (prev, curr, next)
            pixels = load_8_pixels_AVX(src, x, y)
            
            // Tính Gx và Gy cho 8 pixels
            gx = compute_gradient_x_AVX(pixels)
            gy = compute_gradient_y_AVX(pixels)
            
            // Tính magnitude: sqrt(gx^2 + gy^2)
            magnitude = sqrt_AVX(gx^2 + gy^2)
            
            // Lưu kết quả
            store_8_pixels_AVX(dst, x, y, magnitude)
\end{lstlisting}

\section{Tích hợp Sobel vào pipeline AI}

\subsection{Sobel trước model}

Bộ lọc Sobel được áp dụng trước khi đưa vào mô hình detection để:
\begin{itemize}
    \item Tăng cường thông tin biên của biển số
    \item Giảm nhiễu và các chi tiết không liên quan
    \item Tạo đặc trưng đầu vào tốt hơn cho mô hình
\end{itemize}

\subsection{Chuẩn hóa ảnh}

Sau khi áp dụng Sobel, ảnh được chuẩn hóa:
\begin{itemize}
    \item Chuyển đổi sang grayscale nếu cần
    \item Normalize giá trị pixel về khoảng [0, 1] hoặc [-1, 1]
    \item Resize về kích thước input của model (640x640 cho detection)
\end{itemize}

\subsection{Resize phù hợp input model}

Model YOLOv5 yêu cầu input kích thước cố định (640x640). Pipeline tự động resize ảnh với giữ nguyên tỷ lệ khung hình và thêm padding nếu cần.

\section{Mô hình phát hiện biển số}

\subsection{Cấu trúc model}

Model detection sử dụng YOLOv5-nano với cấu trúc:
\begin{itemize}
    \item Input layer: 640x640x3 (RGB)
    \item Backbone: CSPDarknet53 với các lớp convolution và residual blocks
    \item Neck: PANet để tổng hợp đặc trưng đa tỷ lệ
    \item Head: Detection head với 3 scale (small, medium, large objects)
\end{itemize}

\subsection{Input shape}

\begin{itemize}
    \item Kích thước: 640x640 pixels
    \item Channels: 3 (RGB)
    \item Data type: Float32, giá trị normalized [0, 1]
\end{itemize}

\subsection{Output bounding box}

Model trả về:
\begin{itemize}
    \item Tọa độ bounding box: $(x_{center}, y_{center}, width, height)$ hoặc $(x_1, y_1, x_2, y_2)$
    \item Confidence score: Độ tin cậy của detection (0-1)
    \item Class ID: ID của lớp (biển số)
\end{itemize}

\subsection{Tham số huấn luyện}

Model được huấn luyện với:
\begin{itemize}
    \item Dataset: Tập dữ liệu biển số xe Việt Nam
    \item Epochs: 61 (cho detection), 62 (cho OCR)
    \item Batch size: Phụ thuộc vào GPU memory
    \item Learning rate: Sử dụng learning rate schedule của YOLOv5
    \item Augmentation: Random flip, color jitter, mosaic, mixup
\end{itemize}

\section{Luồng xử lý tổng thể}

\subsection{Sơ đồ khối hệ thống}

Hệ thống sử dụng kiến trúc pipeline với 5 threads độc lập và các queue thread-safe để truyền dữ liệu giữa các stage:

\begin{itemize}
    \item \textbf{Thread 1 - Capture:} Đọc frame từ camera/file và đưa vào qCapture\_
    \item \textbf{Thread 2 - Sobel:} Lấy frame từ qCapture\_, áp dụng Sobel, đưa vào qSobel\_
    \item \textbf{Thread 3 - Detection:} Lấy frame từ qSobel\_, chạy detection model, đưa vào qDetect\_
    \item \textbf{Thread 4 - OCR:} Lấy frame từ qDetect\_, cắt ROI và chạy OCR cho tất cả biển số song song, đưa vào qOCR\_
    \item \textbf{Thread 5 - Render:} Lấy frame từ qOCR\_, vẽ bounding box và text, hiển thị kết quả
\end{itemize}

\subsection{Trình tự xử lý dữ liệu}

Mỗi frame đi qua các bước sau:

\begin{enumerate}
    \item \textbf{Capture:} Frame được đọc và đóng gói vào FramePacket
    \item \textbf{Sobel:} Áp dụng Sobel filter (ưu tiên CUDA, fallback SIMD, cuối cùng OpenMP scalar)
    \item \textbf{Preprocessing:} Resize, normalize, chuyển đổi format cho model
    \item \textbf{Detection:} Chạy YOLOv5 detection model qua ONNX Runtime
    \item \textbf{Post-processing:} NMS (Non-Maximum Suppression) để loại bỏ duplicate detections
    \item \textbf{OCR:} Với mỗi bounding box, cắt ROI và chạy OCR model (song song nếu có nhiều biển số)
    \item \textbf{Render:} Vẽ kết quả lên frame và hiển thị
\end{enumerate}

\chapter{CÀI ĐẶT VÀ THỰC NGHIỆM}

\section{Môi trường thực nghiệm}

\subsection{Phần cứng}

\textbf{CPU:} Processor đa lõi hỗ trợ AVX2 (Advanced Vector Extensions 2) để tận dụng SIMD vectorization.

\textbf{GPU:} NVIDIA GPU với CUDA support (tùy chọn, nếu có sẽ sử dụng CUDA kernel cho Sobel).

\textbf{Bộ nhớ:} RAM đủ để xử lý ảnh và load model ONNX vào memory.

\subsection{Phần mềm}

\textbf{Programming Language:} C++17 với các thư viện:
\begin{itemize}
    \item OpenCV 4.x: Xử lý ảnh cơ bản, I/O
    \item ONNX Runtime 1.16.3: Chạy inference cho YOLOv5 models
    \item OpenMP: Song song hóa đa luồng trên CPU
    \item CUDA Toolkit (nếu có GPU): Compile và chạy CUDA kernels
\end{itemize}

\textbf{Framework AI:} ONNX Runtime cho inference, models được export từ PyTorch (YOLOv5) sang ONNX format.

\textbf{Build System:} CMake hoặc script build tự động với các flags:
\begin{itemize}
    \item \texttt{-fopenmp}: Bật OpenMP
    \item \texttt{-mavx2}: Bật AVX-256 instructions
    \item \texttt{-std=c++17}: C++ standard
\end{itemize}

\section{Dataset}

\subsection{Nguồn dữ liệu}

Dataset được sử dụng để huấn luyện model detection và OCR:
\begin{itemize}
    \item Tập dữ liệu biển số xe Việt Nam
    \item Bao gồm nhiều điều kiện: ban ngày, ban đêm, nhiều góc chụp
    \item Đã được annotate với bounding boxes và text labels
\end{itemize}

\subsection{Số lượng ảnh}

\begin{itemize}
    \item Training set: Khoảng vài nghìn ảnh
    \item Validation set: Khoảng 20\% của training set
    \item Test set: Ảnh thực tế từ camera hoặc file
\end{itemize}

\subsection{Điều kiện chụp}

Dataset bao gồm các điều kiện đa dạng:
\begin{itemize}
    \item Ánh sáng: Ban ngày, ban đêm, bóng râm
    \item Góc chụp: Trực diện, nghiêng, từ trên xuống
    \item Khoảng cách: Gần, xa, độ phân giải khác nhau
    \item Môi trường: Trong nhà, ngoài trời, bãi đỗ xe
\end{itemize}

\section{Các kịch bản thực nghiệm}

\subsection{Không Sobel}

Baseline: Chạy detection model trực tiếp trên ảnh gốc không qua bộ lọc Sobel.

\textbf{Mục đích:} Đánh giá hiệu suất cơ bản của model không có tiền xử lý.

\subsection{Sobel đơn luồng}

Áp dụng bộ lọc Sobel với implementation scalar (không song song hóa).

\textbf{Mục đích:} Đo lường overhead của Sobel và so sánh với baseline.

\subsection{Sobel song song}

Áp dụng bộ lọc Sobel với các phương pháp song song hóa:

\textbf{CPU OpenMP (scalar):} Song song hóa theo dòng với OpenMP nhưng vẫn dùng code scalar.

\textbf{CPU SIMD (AVX-256):} Kết hợp OpenMP và SIMD vectorization, xử lý 8 pixels cùng lúc.

\textbf{GPU CUDA:} Triển khai CUDA kernel để xử lý song song trên GPU.

\section{Chỉ số đánh giá}

\subsection{Độ chính xác (Accuracy)}

\textbf{Precision:} Tỷ lệ các detection đúng trong tổng số detections:
\begin{equation}
Precision = \frac{TP}{TP + FP}
\end{equation}

\textbf{Recall:} Tỷ lệ các biển số thực tế được phát hiện:
\begin{equation}
Recall = \frac{TP}{TP + FN}
\end{equation}

\textbf{mAP (mean Average Precision):} Trung bình của Average Precision ở các ngưỡng IoU khác nhau.

\subsection{Thời gian xử lý}

\textbf{Latency:} Thời gian xử lý một frame từ đầu đến cuối (end-to-end latency).

\textbf{Throughput:} Số frame xử lý được trong một giây (FPS - Frames Per Second).

\subsection{FPS}

FPS được tính bằng:
\begin{equation}
FPS = \frac{1}{Latency_{avg}}
\end{equation}

Trong đó $Latency_{avg}$ là thời gian trung bình xử lý một frame.

\subsection{Latency}

Đo lường latency cho từng stage:
\begin{itemize}
    \item Sobel processing time
    \item Detection inference time
    \item OCR inference time
    \item Total pipeline latency
\end{itemize}

\section{Kết quả thực nghiệm}

\subsection{Bảng so sánh}

Dựa trên benchmark results từ file \texttt{benchmark\_results.txt}, kết quả cho ảnh 800x600 pixels (0.48 MP):

\begin{table}[H]
\centering
\caption{So sánh hiệu năng các phương pháp Sobel (100 runs average)}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Phương pháp} & \textbf{Thời gian (ms)} & \textbf{Speedup} & \textbf{FPS} \\
\hline
CPU OpenMP (scalar) & 7.144 & 1.0x (baseline) & 140.0 \\
CPU SIMD (AVX-256) & 1.885 & 3.79x & 530.4 \\
GPU CUDA & 0.494 & 14.47x & 2025.5 \\
\hline
\end{tabular}
\end{table}

\subsection{Phân tích kết quả}

\textbf{SIMD vectorization:} Cho thấy cải thiện 3.79x so với scalar code, đạt 530.4 FPS. Điều này chứng tỏ việc tận dụng SIMD instructions của CPU rất hiệu quả.

\textbf{GPU CUDA:} Đạt speedup 14.47x so với baseline và 3.82x so với SIMD, đạt 2025.5 FPS. GPU phù hợp cho xử lý real-time với throughput cao.

\textbf{So sánh chi tiết:}
\begin{itemize}
    \item CUDA vs CPU scalar: 14.47x nhanh hơn
    \item CUDA vs SIMD: 3.82x nhanh hơn
    \item SIMD vs CPU scalar: 3.79x nhanh hơn
\end{itemize}

\subsection{Biểu đồ hiệu năng}

\textbf{Biểu đồ thời gian xử lý:} (Có thể vẽ biểu đồ cột so sánh thời gian của 3 phương pháp)

\textbf{Biểu đồ FPS:} (Có thể vẽ biểu đồ cột so sánh FPS của 3 phương pháp)

\textbf{Biểu đồ speedup:} (Có thể vẽ biểu đồ cột so sánh speedup so với baseline)

\chapter{ĐÁNH GIÁ VÀ THẢO LUẬN}

\section{Phân tích kết quả}

\subsection{Sobel ảnh hưởng thế nào tới model}

\textbf{Tăng cường thông tin biên:} Bộ lọc Sobel làm nổi bật các cạnh và đường viền trong ảnh, đặc biệt là các đường thẳng ngang và dọc của biển số. Điều này giúp model dễ dàng phát hiện vùng biển số hơn.

\textbf{Giảm nhiễu:} Bằng cách tập trung vào thông tin biên, Sobel giúp loại bỏ các chi tiết không liên quan và nhiễu trong ảnh, tạo đầu vào "sạch" hơn cho model.

\textbf{Ảnh hưởng đến accuracy:} Tùy thuộc vào điều kiện ảnh, Sobel có thể cải thiện hoặc giảm độ chính xác. Với ảnh có nhiều nhiễu hoặc độ tương phản thấp, Sobel thường cải thiện kết quả. Tuy nhiên, với ảnh chất lượng tốt, Sobel có thể không cần thiết hoặc thậm chí làm mất một số thông tin màu sắc.

\subsection{Lợi ích song song hóa}

\textbf{Tăng throughput:} Song song hóa cho phép xử lý nhiều frame hơn trong cùng một khoảng thời gian. Với CUDA, có thể đạt hơn 2000 FPS cho Sobel filter, đủ cho nhiều ứng dụng real-time.

\textbf{Giảm latency:} Mặc dù latency của một frame có thể không giảm nhiều (do overhead), nhưng với pipeline parallelism, các frame có thể được xử lý chồng chéo, giảm latency tổng thể.

\textbf{Tận dụng tài nguyên:} Song song hóa tận dụng tối đa các lõi CPU và GPU, tăng hiệu quả sử dụng phần cứng.

\subsection{So sánh các phương pháp song song}

\textbf{CPU OpenMP (scalar):} Đơn giản, dễ triển khai, hoạt động trên mọi CPU đa lõi. Tuy nhiên, không tận dụng được SIMD units của CPU.

\textbf{CPU SIMD (AVX-256):} Cân bằng tốt giữa hiệu năng và tính tương thích. Không cần GPU, nhưng yêu cầu CPU hỗ trợ AVX2. Đạt speedup 3.79x so với scalar.

\textbf{GPU CUDA:} Nhanh nhất, phù hợp cho throughput cao. Tuy nhiên, yêu cầu GPU NVIDIA và có overhead khi transfer data giữa CPU-GPU.

\section{So sánh với phương pháp khác}

\subsection{Không tiền xử lý}

Pipeline không có Sobel sẽ:
\begin{itemize}
    \item Nhanh hơn (bỏ qua bước Sobel)
    \item Có thể kém chính xác hơn với ảnh nhiễu hoặc độ tương phản thấp
    \item Phụ thuộc hoàn toàn vào khả năng của model học sâu
\end{itemize}

\subsection{Tiền xử lý truyền thống}

Các phương pháp tiền xử lý khác có thể so sánh:
\begin{itemize}
    \item \textbf{Gaussian Blur:} Làm mờ để giảm nhiễu, nhưng có thể làm mất chi tiết
    \item \textbf{Histogram Equalization:} Cải thiện độ tương phản, nhưng có thể làm tăng nhiễu
    \item \textbf{Canny Edge Detection:} Tương tự Sobel nhưng phức tạp hơn, có thể chậm hơn
\end{itemize}

Sobel được chọn vì cân bằng tốt giữa hiệu năng và hiệu quả, dễ song song hóa.

\section{Hạn chế của đề tài}

\subsection{Nhạy nhiễu}

Bộ lọc Sobel có thể nhạy cảm với nhiễu trong ảnh. Khi ảnh có nhiều nhiễu, Sobel có thể tạo ra nhiều biên giả (false edges), ảnh hưởng đến kết quả detection.

\textbf{Giải pháp:} Có thể kết hợp với Gaussian blur trước khi áp dụng Sobel để giảm nhiễu.

\subsection{Điều kiện ánh sáng xấu}

Với điều kiện ánh sáng rất tối hoặc quá sáng, Sobel có thể không hiệu quả. Model học sâu có thể xử lý tốt hơn trong các điều kiện này nếu được huấn luyện đúng cách.

\subsection{Tài nguyên phần cứng}

\textbf{GPU:} Phương pháp CUDA yêu cầu GPU NVIDIA, không phải hệ thống nào cũng có.

\textbf{CPU:} SIMD yêu cầu CPU hỗ trợ AVX2, một số CPU cũ có thể không hỗ trợ.

\textbf{Bộ nhớ:} Pipeline với nhiều frame buffer yêu cầu bộ nhớ đủ lớn, đặc biệt với video độ phân giải cao.

\subsection{Hạn chế khác}

\begin{itemize}
    \item Pipeline hiện tại chưa tối ưu batch inference cho model (xử lý từng frame một)
    \item Chưa có cơ chế adaptive quality (tự động điều chỉnh chất lượng theo FPS)
    \item Chưa hỗ trợ multi-GPU để tăng throughput hơn nữa
\end{itemize}

\chapter{KẾT LUẬN VÀ HƯỚNG PHÁT TRIỂN}

\section{Kết luận}

\subsection{Tổng kết kết quả đạt được}

Đề tài đã thành công trong việc:

\textbf{Triển khai pipeline song song:} Xây dựng hệ thống xử lý ảnh với 5 threads độc lập, tận dụng cả Data Parallelism (SIMD, OpenMP) và Task Parallelism (tách Detection/OCR).

\textbf{Tối ưu Sobel filter:} Đạt được speedup đáng kể:
\begin{itemize}
    \item SIMD: 3.79x so với scalar code
    \item CUDA: 14.47x so với scalar code, 3.82x so với SIMD
\end{itemize}

\textbf{Tích hợp model học sâu:} Kết hợp thành công YOLOv5 với pipeline tiền xử lý Sobel, tạo hệ thống nhận dạng biển số hoàn chỉnh.

\subsection{Mức cải thiện so với baseline}

So với pipeline không có tối ưu:
\begin{itemize}
    \item \textbf{Sobel processing:} Từ 7.144ms (scalar) xuống 0.494ms (CUDA) - cải thiện 14.47x
    \item \textbf{Throughput:} Từ 140 FPS (scalar) lên 2025.5 FPS (CUDA) cho Sobel filter
    \item \textbf{Pipeline latency:} Giảm đáng kể nhờ song song hóa các stage
\end{itemize}

\subsection{Đóng góp chính}

\begin{enumerate}
    \item Đề xuất và triển khai pipeline tiền xử lý song song với nhiều tầng tối ưu
    \item So sánh chi tiết các phương pháp song song hóa (scalar, SIMD, CUDA)
    \item Đánh giá ảnh hưởng của Sobel filter đến hiệu suất model học sâu
    \item Cung cấp benchmark và code mẫu có thể tái sử dụng
\end{enumerate}

\section{Hướng phát triển}

\subsection{OCR biển số}

\textbf{Cải thiện accuracy:} 
\begin{itemize}
    \item Fine-tune OCR model với dataset lớn hơn và đa dạng hơn
    \item Xử lý các trường hợp đặc biệt: biển số cũ, biển số nước ngoài
    \item Post-processing để sửa lỗi nhận dạng (spell checking, format validation)
\end{itemize}

\textbf{Tối ưu tốc độ:}
\begin{itemize}
    \item Batch inference cho nhiều ROI cùng lúc
    \item Quantization model để giảm kích thước và tăng tốc
    \item Sử dụng TensorRT cho NVIDIA GPU
\end{itemize}

\subsection{Real-time video}

\textbf{Video streaming:}
\begin{itemize}
    \item Hỗ trợ RTSP stream từ IP camera
    \item Xử lý video với frame rate cao (60 FPS+)
    \item Adaptive frame skipping để duy trì real-time
\end{itemize}

\textbf{Tracking:}
\begin{itemize}
    \item Triển khai object tracking để theo dõi biển số qua nhiều frame
    \item Giảm số lần chạy detection bằng cách sử dụng tracking
    \item Cải thiện accuracy bằng cách tích hợp thông tin từ nhiều frame
\end{itemize}

\subsection{Triển khai Edge AI}

\textbf{Optimization cho edge devices:}
\begin{itemize}
    \item Model quantization (INT8) để giảm kích thước và tăng tốc
    \item Model pruning để loại bỏ các tham số không cần thiết
    \item Knowledge distillation để tạo model nhỏ hơn nhưng vẫn giữ accuracy
\end{itemize}

\textbf{Hardware acceleration:}
\begin{itemize}
    \item Tận dụng NPU (Neural Processing Unit) trên các thiết bị edge
    \item Optimize cho ARM CPU với NEON SIMD
    \item Hỗ trợ các framework edge như TensorFlow Lite, ONNX Runtime Mobile
\end{itemize}

\subsection{Tối ưu GPU sâu hơn}

\textbf{CUDA streams:}
\begin{itemize}
    \item Sử dụng multiple CUDA streams để overlap computation và data transfer
    \item Pipeline parallelism trên GPU để xử lý nhiều frame cùng lúc
\end{itemize}

\textbf{Memory optimization:}
\begin{itemize}
    \item Unified memory để giảm overhead copy CPU-GPU
    \item Memory pooling để tái sử dụng buffer
    \item Tối ưu memory access pattern
\end{itemize}

\textbf{Multi-GPU:}
\begin{itemize}
    \item Phân phối workload cho nhiều GPU
    \item Một GPU cho detection, GPU khác cho OCR
    \item Load balancing giữa các GPU
\end{itemize}

\subsection{Các hướng phát triển khác}

\textbf{Deep learning optimization:}
\begin{itemize}
    \item Thử nghiệm các kiến trúc model mới (YOLOv8, YOLOv9, DETR)
    \item Transfer learning với dataset lớn hơn
    \item Ensemble methods để tăng accuracy
\end{itemize}

\textbf{System integration:}
\begin{itemize}
    \item REST API để tích hợp với hệ thống khác
    \item Database để lưu trữ kết quả nhận dạng
    \item Dashboard để monitoring và quản lý
\end{itemize}

\textbf{Advanced features:}
\begin{itemize}
    \item Nhận dạng loại xe (ô tô, xe máy, xe tải)
    \item Phát hiện vi phạm (đỗ xe sai, quá tốc độ)
    \item Phân tích lưu lượng giao thông
\end{itemize}

\section{Lời cảm ơn}

Xin chân thành cảm ơn thầy/cô hướng dẫn và các bạn đã hỗ trợ trong quá trình thực hiện đề tài.

\appendix

\chapter{Mã nguồn quan trọng}

\section{Pipeline Architecture}

Kiến trúc pipeline với 5 threads và các queue thread-safe được triển khai trong \texttt{Pipeline.h} và \texttt{Pipeline.cpp}.

\section{Sobel SIMD Implementation}

Implementation Sobel với AVX-256 được triển khai trong \texttt{SobelSIMD.cpp}, sử dụng intrinsics để xử lý 8 pixels cùng lúc.

\section{CUDA Kernel}

CUDA kernel cho Sobel được triển khai trong \texttt{SobelCuda.cu}, với mỗi thread xử lý một pixel.

\chapter{Bảng ký hiệu và thuật ngữ}

\begin{itemize}
    \item \textbf{FPS:} Frames Per Second - Số khung hình mỗi giây
    \item \textbf{Latency:} Độ trễ - Thời gian xử lý từ đầu đến cuối
    \item \textbf{SIMD:} Single Instruction Multiple Data - Một lệnh xử lý nhiều dữ liệu
    \item \textbf{AVX:} Advanced Vector Extensions - Mở rộng vector của Intel
    \item \textbf{CUDA:} Compute Unified Device Architecture - Kiến trúc tính toán của NVIDIA
    \item \textbf{ONNX:} Open Neural Network Exchange - Định dạng trao đổi mô hình neural network
    \item \textbf{YOLO:} You Only Look Once - Kiến trúc object detection
    \item \textbf{NMS:} Non-Maximum Suppression - Loại bỏ detection trùng lặp
    \item \textbf{ROI:} Region of Interest - Vùng quan tâm
    \item \textbf{OCR:} Optical Character Recognition - Nhận dạng ký tự quang học
\end{itemize}

\end{document}

