\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[vietnamese]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=2.5cm}

% Cấu hình cho code listings
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    showstringspaces=false
}

\title{BÁO CÁO ĐỒ ÁN\\
Tối Ưu Hóa Song Song Bộ Lọc Sobel\\
Trong Hệ Thống Nhận Dạng Biển Số Xe\\
Sử Dụng Mô Hình Học Sâu}
\author{Sinh viên thực hiện}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\listoffigures
\listoftables

\newpage

\chapter{GIỚI THIỆU}

\section{Đặt vấn đề}

\subsection{Bài toán}

Trong thời đại công nghệ hiện đại, việc nhận dạng biển số xe tự động đóng vai trò quan trọng trong nhiều ứng dụng thực tế:

\textbf{Giám sát giao thông:} Hệ thống nhận dạng biển số giúp tự động hóa việc giám sát và quản lý phương tiện giao thông, phát hiện vi phạm, kiểm soát tốc độ và quản lý lưu lượng giao thông.

\textbf{Bãi giữ xe thông minh:} Tự động hóa quá trình vào/ra của xe, tính phí, quản lý chỗ đỗ xe mà không cần nhân viên canh gác.

\textbf{Nhận dạng phương tiện tự động:} Ứng dụng trong hệ thống thu phí điện tử, kiểm soát an ninh, và quản lý đội xe.

\subsection{Khó khăn}

Tuy nhiên, việc nhận dạng biển số xe trong môi trường thực tế gặp nhiều thách thức:

\textbf{Nhiễu ảnh:} Ảnh có thể bị nhiễu do điều kiện thời tiết, chất lượng camera, hoặc khoảng cách chụp.

\textbf{Ánh sáng thay đổi:} Điều kiện ánh sáng thay đổi liên tục (ban ngày, ban đêm, bóng râm) ảnh hưởng đến chất lượng nhận dạng.

\textbf{Ảnh độ phân giải thấp:} Camera đặt xa hoặc chất lượng thấp dẫn đến ảnh mờ, khó nhận dạng.

\textbf{Tốc độ xử lý real-time:} Yêu cầu xử lý nhanh để đáp ứng ứng dụng thời gian thực, đặc biệt trong video streaming.

\section{Mục tiêu đề tài}

Đề tài tập trung vào việc tối ưu hóa pipeline nhận dạng biển số xe thông qua các mục tiêu cụ thể:

\subsection{Áp dụng bộ lọc Sobel}

\textbf{Làm nổi biên:} Sử dụng bộ lọc Sobel để phát hiện và làm nổi bật các cạnh trong ảnh, giúp tăng cường thông tin biên của biển số xe.

\textbf{Giảm nhiễu không cần thiết:} Bộ lọc Sobel giúp loại bỏ các chi tiết không liên quan, tập trung vào các đặc trưng quan trọng của biển số.

\subsection{Song song hóa Sobel}

Để đạt được tốc độ xử lý cao, đề tài triển khai song song hóa bộ lọc Sobel theo nhiều phương pháp:

\textbf{CPU đa luồng:} Sử dụng OpenMP để chia nhỏ ảnh và xử lý song song trên nhiều lõi CPU.

\textbf{GPU:} Triển khai kernel CUDA để tận dụng sức mạnh tính toán song song của GPU.

\textbf{GPU:} Triển khai kernel CUDA để tận dụng sức mạnh tính toán song song của GPU.

\subsection{Kết hợp model học sâu}

\textbf{Phát hiện biển số chính xác hơn:} Sử dụng mô hình YOLOv5 để phát hiện vùng biển số với độ chính xác cao.

\textbf{Giảm thời gian suy luận:} Tối ưu pipeline để giảm latency và tăng throughput, đáp ứng yêu cầu real-time.

\section{Phạm vi nghiên cứu}

Đề tài tập trung vào các phạm vi sau:

\textbf{Ảnh tĩnh và video:} Hệ thống có thể xử lý cả ảnh đơn lẻ và luồng video từ camera.

\textbf{Tiền xử lý với Sobel:} Nghiên cứu ảnh hưởng của bộ lọc Sobel đến hiệu suất nhận dạng, không đi sâu vào phần OCR (chỉ sử dụng model OCR có sẵn).

\textbf{So sánh hiệu năng:} So sánh hiệu suất giữa pipeline có và không có bộ lọc Sobel, cũng như so sánh các phương pháp song song hóa khác nhau.

\section{Đóng góp của đề tài}

Đề tài đóng góp các điểm sau:

\textbf{Đề xuất pipeline tiền xử lý song song:} Thiết kế và triển khai pipeline xử lý ảnh song song với tối ưu CUDA cho Sobel filter.

\textbf{Đánh giá ảnh hưởng Sobel tới model:} Phân tích và đánh giá tác động của bộ lọc Sobel đến độ chính xác và tốc độ của mô hình học sâu.

\textbf{So sánh hiệu năng:} Cung cấp benchmark chi tiết so sánh các phương pháp song song hóa (CPU scalar, CUDA) về FPS và latency, với phân tích chi tiết chiến thuật song song hóa CUDA.

\chapter{CƠ SỞ LÝ THUYẾT}

\section{Tổng quan xử lý ảnh số}

\subsection{Khái niệm cơ bản}

\textbf{Pixel:} Pixel (picture element) là đơn vị nhỏ nhất của ảnh số, mỗi pixel chứa thông tin về màu sắc và độ sáng tại một vị trí cụ thể.

\textbf{Kernel:} Kernel (hay filter) là một ma trận nhỏ được sử dụng để thực hiện các phép toán convolution trên ảnh, thường có kích thước 3x3, 5x5, hoặc lớn hơn.

\textbf{Convolution:} Convolution là phép toán cơ bản trong xử lý ảnh, trong đó kernel được "trượt" qua ảnh để tính giá trị mới cho mỗi pixel dựa trên các pixel xung quanh.

\subsection{Lọc không gian (Spatial Filtering)}

Lọc không gian là kỹ thuật xử lý ảnh trực tiếp trên miền không gian (spatial domain), thay vì chuyển sang miền tần số. Có hai loại chính:

\textbf{Lọc tuyến tính:} Sử dụng convolution với kernel tuyến tính, ví dụ: Gaussian blur, Sobel, Laplacian.

\textbf{Lọc phi tuyến:} Sử dụng các phép toán phi tuyến, ví dụ: median filter, morphological operations.

\section{Bộ lọc Sobel}

\subsection{Nguyên lý phát hiện biên}

Bộ lọc Sobel là một toán tử gradient được sử dụng để phát hiện biên trong ảnh. Nguyên lý hoạt động dựa trên việc tính gradient (độ dốc) của cường độ pixel:

\begin{equation}
G = \sqrt{G_x^2 + G_y^2}
\end{equation}

Trong đó $G_x$ và $G_y$ là gradient theo hướng ngang và dọc.

\subsection{Kernel Sobel}

Bộ lọc Sobel sử dụng hai kernel riêng biệt để tính gradient theo hai hướng:

\textbf{Kernel Gx (gradient ngang):}
\begin{equation}
G_x = \begin{bmatrix}
-1 & 0 & 1 \\
-2 & 0 & 2 \\
-1 & 0 & 1
\end{bmatrix}
\end{equation}

\textbf{Kernel Gy (gradient dọc):}
\begin{equation}
G_y = \begin{bmatrix}
-1 & -2 & -1 \\
0 & 0 & 0 \\
1 & 2 & 1
\end{bmatrix}
\end{equation}

\subsection{Đặc điểm}

\textbf{Nhấn mạnh biên:} Sobel làm nổi bật các vùng có sự thay đổi đột ngột về cường độ, đặc biệt hiệu quả với biên dọc và ngang.

\textbf{Nhạy với nhiễu:} Do tính chất gradient, Sobel có thể nhạy cảm với nhiễu trong ảnh. Có thể kết hợp với Gaussian blur để giảm nhiễu trước khi áp dụng Sobel.

\section{Song song trong xử lý ảnh}

\subsection{Tính chất}

Xử lý ảnh có tính chất song song tự nhiên:

\textbf{Mỗi pixel xử lý độc lập:} Trong nhiều phép toán xử lý ảnh (như Sobel), việc tính toán giá trị pixel mới chỉ phụ thuộc vào các pixel lân cận, không phụ thuộc vào kết quả của các pixel khác. Điều này cho phép xử lý song song hiệu quả.

\subsection{Các mô hình song song}

\textbf{CPU đa luồng (OpenMP, Threading):} Chia ảnh thành các vùng và gán mỗi vùng cho một thread xử lý. OpenMP cung cấp các directive đơn giản để song song hóa vòng lặp.

\textbf{GPU (CUDA / OpenCL):} Tận dụng hàng nghìn lõi tính toán của GPU để xử lý song song ở mức độ hạt mịn (fine-grained parallelism). Mỗi thread GPU có thể xử lý một hoặc một nhóm pixel nhỏ.

\subsection{CUDA Parallelism}

\subsubsection{Kiến trúc CUDA}

CUDA (Compute Unified Device Architecture) là kiến trúc tính toán song song của NVIDIA cho phép lập trình viên sử dụng GPU như một bộ xử lý đa lõi.

\textbf{Thành phần chính:}
\begin{itemize}
    \item \textbf{Thread:} Đơn vị tính toán nhỏ nhất, mỗi thread xử lý một pixel
    \item \textbf{Block:} Nhóm các thread (thường 16x16 = 256 threads)
    \item \textbf{Grid:} Tập hợp các blocks để bao phủ toàn bộ ảnh
    \item \textbf{Warp:} 32 threads được thực thi đồng thời trên một SM (Streaming Multiprocessor)
\end{itemize}

\textbf{Memory hierarchy:}
\begin{itemize}
    \item \textbf{Global memory:} Bộ nhớ chính của GPU, lớn nhưng chậm
    \item \textbf{Shared memory:} Bộ nhớ nhanh được chia sẻ giữa các thread trong cùng một block
    \item \textbf{Registers:} Bộ nhớ nhanh nhất, riêng cho mỗi thread
\end{itemize}

\subsubsection{Triển khai Sobel với CUDA}

Trong đề tài, Sobel filter được triển khai với CUDA kernel đơn giản:

\textbf{Kernel function:}
\begin{itemize}
    \item Mỗi thread xử lý một pixel duy nhất
    \item Tính toán thread ID từ block và thread index: \texttt{x = blockIdx.x * blockDim.x + threadIdx.x} và \texttt{y = blockIdx.y * blockDim.y + threadIdx.y}
    \item Kiểm tra biên để tránh truy cập ngoài phạm vi
    \item Load 9 pixels từ 3x3 neighborhood
    \item Tính gradient X và Y theo công thức Sobel
    \item Tính magnitude và clamp về [0, 255]
    \item Ghi kết quả vào global memory
\end{itemize}

\textbf{Thread block configuration:}
\begin{itemize}
    \item Block size: 16x16 = 256 threads (tối ưu cho hầu hết GPU)
    \item Grid size: Tính toán để bao phủ toàn bộ ảnh:
    \begin{equation}
    grid\_x = \lceil width / block\_x \rceil
    \end{equation}
    \begin{equation}
    grid\_y = \lceil height / block\_y \rceil
    \end{equation}
\end{itemize}

\textbf{Memory management:}
\begin{itemize}
    \item \textbf{Allocate:} Sử dụng \texttt{cudaMalloc} để cấp phát bộ nhớ trên GPU cho input và output
    \item \textbf{Transfer:} \texttt{cudaMemcpy} để copy dữ liệu từ CPU sang GPU (Host-to-Device) và ngược lại (Device-to-Host)
    \item \textbf{Free:} \texttt{cudaFree} để giải phóng bộ nhớ sau khi sử dụng
\end{itemize}

\textbf{Execution flow:}
\begin{enumerate}
    \item Allocate memory trên GPU cho input và output
    \item Copy ảnh từ CPU memory sang GPU memory (Host-to-Device)
    \item Launch kernel với grid và block configuration phù hợp
    \item Synchronize để đợi kernel hoàn thành
    \item Copy kết quả từ GPU memory về CPU memory (Device-to-Host)
    \item Free GPU memory
\end{enumerate}

\subsubsection{Tối ưu hóa CUDA}

\textbf{Memory coalescing:}
\begin{itemize}
    \item Các thread trong cùng một warp nên truy cập bộ nhớ liên tiếp để tận dụng memory coalescing
    \item Trong Sobel kernel, mỗi thread truy cập các pixel khác nhau, nhưng pattern truy cập vẫn hiệu quả
\end{itemize}

\textbf{Shared memory (có thể cải thiện):}
\begin{itemize}
    \item Có thể sử dụng shared memory để cache các dòng ảnh được sử dụng nhiều lần
    \item Giảm số lần truy cập global memory
    \item Tuy nhiên, với Sobel 3x3, overhead của shared memory có thể không đáng kể
\end{itemize}

\textbf{Occupancy:}
\begin{itemize}
    \item Block size 16x16 thường đạt occupancy tốt trên hầu hết GPU
    \item Cần cân bằng giữa số thread per block và số register sử dụng
\end{itemize}

\subsubsection{Ưu điểm và hạn chế của CUDA}

\textbf{Ưu điểm:}
\begin{itemize}
    \item Tốc độ rất cao: 14-15x nhanh hơn CPU scalar code
    \item Tận dụng hàng nghìn lõi tính toán của GPU
    \item Phù hợp cho xử lý ảnh lớn và real-time
    \item Có thể xử lý nhiều ảnh song song (batch processing)
\end{itemize}

\textbf{Hạn chế:}
\begin{itemize}
    \item Yêu cầu GPU NVIDIA và CUDA toolkit
    \item Overhead của memory transfer CPU-GPU
    \item Chi phí phần cứng cao hơn
    \item Code phức tạp hơn, cần kiến thức về GPU programming
    \item Không portable sang các GPU khác (AMD, Intel)
\end{itemize}


\section{Bài toán phát hiện biển số xe}

\subsection{Object Detection}

Phát hiện biển số xe là một bài toán object detection, yêu cầu:
\begin{itemize}
    \item Xác định vị trí biển số trong ảnh (bounding box)
    \item Phân loại đối tượng (có phải biển số hay không)
    \item Xử lý trường hợp có nhiều biển số trong một ảnh
\end{itemize}

\subsection{Các hướng tiếp cận}

\textbf{Truyền thống:} 
\begin{itemize}
    \item Haar Cascade: Sử dụng đặc trưng Haar và AdaBoost
    \item Edge-based: Dựa trên phát hiện biên và hình dạng hình học
    \item Template matching: So khớp với mẫu biển số
\end{itemize}

\textbf{Học sâu:}
\begin{itemize}
    \item YOLO (You Only Look Once): Phát hiện đối tượng trong một lần duyệt qua mạng, nhanh và hiệu quả
    \item SSD (Single Shot Detector): Tương tự YOLO, sử dụng nhiều scale
    \item Faster R-CNN: Chính xác hơn nhưng chậm hơn, sử dụng region proposal
\end{itemize}

\section{Mô hình học sâu sử dụng}

\subsection{Kiến trúc tổng quan}

Đề tài sử dụng YOLOv5 (nano variant) cho cả detection và OCR:

\textbf{YOLOv5 Architecture:}
\begin{itemize}
    \item Backbone: CSPDarknet53 (Cross Stage Partial Network)
    \item Neck: PANet (Path Aggregation Network)
    \item Head: Detection head với anchor-based detection
\end{itemize}

\subsection{Đầu vào / Đầu ra}

\textbf{Detection Model:}
\begin{itemize}
    \item Input: Ảnh RGB kích thước 640x640 pixels
    \item Output: Bounding boxes với confidence scores và class IDs
    \item Format: ONNX (Open Neural Network Exchange)
\end{itemize}

\textbf{OCR Model:}
\begin{itemize}
    \item Input: Ảnh ROI biển số đã cắt, kích thước 320x320 pixels
    \item Output: Các ký tự được nhận dạng với confidence scores
\end{itemize}

\subsection{Loss function}

YOLOv5 sử dụng loss function kết hợp:
\begin{equation}
L_{total} = L_{box} + L_{obj} + L_{cls}
\end{equation}

Trong đó:
\begin{itemize}
    \item $L_{box}$: Loss cho bounding box regression (IoU loss)
    \item $L_{obj}$: Loss cho objectness (có đối tượng hay không)
    \item $L_{cls}$: Loss cho classification
\end{itemize}

\subsection{Ưu điểm và hạn chế}

\textbf{Ưu điểm:}
\begin{itemize}
    \item Tốc độ suy luận nhanh, phù hợp real-time
    \item Độ chính xác cao với model đã được huấn luyện tốt
    \item Hỗ trợ ONNX Runtime, dễ tích hợp vào C++
\end{itemize}

\textbf{Hạn chế:}
\begin{itemize}
    \item Yêu cầu tài nguyên tính toán (GPU khuyến nghị)
    \item Cần dataset lớn và đa dạng để huấn luyện
    \item Nhạy cảm với điều kiện ánh sáng và góc chụp
\end{itemize}

\chapter{PHƯƠNG PHÁP ĐỀ XUẤT}

\section{Tổng quan hệ thống}

\subsection{Pipeline xử lý}

Hệ thống được thiết kế theo kiến trúc pipeline đa tầng với các giai đoạn xử lý tuần tự:

\begin{enumerate}
    \item \textbf{Ảnh gốc:} Nhận ảnh đầu vào từ camera hoặc file
    \item \textbf{Sobel song song:} Áp dụng bộ lọc Sobel với tối ưu song song (CUDA)
    \item \textbf{Ảnh tăng cường biên:} Kết quả Sobel được sử dụng để tăng cường thông tin biên
    \item \textbf{Model phát hiện biển số:} YOLOv5 phát hiện vùng biển số từ ảnh đã xử lý
    \item \textbf{Kết quả bounding box:} Trả về tọa độ và confidence của các biển số phát hiện được
    \item \textbf{OCR (tùy chọn):} Nhận dạng ký tự từ các vùng biển số đã phát hiện
\end{enumerate}

\subsection{Sơ đồ khối}

Pipeline được triển khai với 5 threads độc lập (Task Parallelism): Capture → Sobel → Detection → OCR → Render. Mỗi stage có queue riêng với buffer tối đa 5 frames.

\section{Sobel song song}

\subsection{Implementation hiện tại: Chỉ sử dụng CUDA}

Dựa trên kết quả benchmark, hệ thống đã quyết định chỉ sử dụng CUDA cho Sobel filter (bắt buộc):

\textbf{Quyết định:}
\begin{itemize}
    \item CUDA đạt hiệu năng cao nhất: 14.47x so với OpenMP baseline
    \item Phù hợp cho production system với yêu cầu real-time
    \item Build bắt buộc phải có CUDA support
\end{itemize}

\textbf{Logic trong code:} Hệ thống sử dụng macro \texttt{USE\_CUDA\_SOBEL} để kiểm tra CUDA support. Nếu CUDA không khả dụng, code sẽ báo lỗi compile-time. Trong runtime, nếu \texttt{sobelCuda()} thất bại, frame sẽ bị bỏ qua.

\textbf{Ý nghĩa:}
\begin{itemize}
    \item Code đơn giản hơn, không có fallback logic phức tạp
    \item Đảm bảo hiệu năng tối đa với GPU
    \item Yêu cầu hệ thống phải có GPU NVIDIA và CUDA toolkit
    \item Nếu cần so sánh với các phương pháp khác, sử dụng các build scripts riêng
\end{itemize}

\textbf{Các build scripts riêng cho benchmark:}
\begin{itemize}
    \item \texttt{build.sh}: Build với CUDA → binary \texttt{lp\_main}
    \item \texttt{build\_simd.sh}: Build với SIMD (chỉ để benchmark so sánh) → binary \texttt{lp\_main\_simd}
    \item \texttt{build\_openmp.sh}: Build với OpenMP only → binary \texttt{lp\_main\_openmp}
    \item \texttt{benchmark.sh}: Tự động build và chạy benchmark cho cả 3 phương pháp
\end{itemize}

\subsection{Cách chia ảnh}

Để tối ưu song song hóa, ảnh được chia theo các chiến lược:

\textbf{Theo dòng:} Chia ảnh thành các dòng và gán mỗi dòng cho một thread (OpenMP) sử dụng directive \texttt{\#pragma omp parallel for}.

\textbf{Theo block:} Chia ảnh thành các block 2D (ví dụ 64x64 pixels) và xử lý song song các block (có thể mở rộng trong tương lai).

\subsection{Chiến lược song song}

\textbf{Multi-thread CPU:} Sử dụng OpenMP để tự động phân phối công việc cho các lõi CPU có sẵn. Mỗi thread xử lý một phần của ảnh độc lập.

\textbf{GPU kernel:} Triển khai CUDA kernel với mỗi thread xử lý một pixel hoặc một nhóm pixel nhỏ. Sử dụng shared memory để tối ưu truy cập dữ liệu.


\subsection{Implementation chi tiết: CUDA Kernel}

\subsubsection{Kernel function}

CUDA kernel được định nghĩa với modifier \texttt{\_\_global\_\_} để có thể được gọi từ CPU. Kernel \texttt{sobelKernel()} tính toán thread ID từ block và thread index, kiểm tra biên, load 3x3 neighborhood, tính gradient X và Y theo công thức Sobel, tính magnitude, và ghi kết quả vào global memory.

\subsubsection{Host code}

Code trên CPU (host) quản lý memory và launch kernel: Hàm \texttt{sobelCuda()} thực hiện các bước: (1) Allocate GPU memory cho input và output, (2) Copy dữ liệu từ CPU sang GPU, (3) Configure kernel launch với block size 16x16 và grid size tính toán để bao phủ toàn bộ ảnh, (4) Launch kernel, (5) Synchronize và copy kết quả về CPU, (6) Free GPU memory.

\subsubsection{Chiến thuật song song hóa CUDA}

Chiến thuật song song hóa trong code hiện tại sử dụng \textbf{fine-grained parallelism} với các đặc điểm sau:

\textbf{1. One-thread-per-pixel mapping:}
\begin{itemize}
    \item Mỗi thread GPU xử lý \textbf{chính xác 1 pixel} trong ảnh
    \item Đây là mức độ song song hóa hạt mịn nhất (fine-grained)
    \item Với ảnh 800x600 = 480,000 pixels → 480,000 threads được tạo ra
    \item Tất cả threads chạy song song trên GPU
\end{itemize}

\textbf{2. 2D Thread-to-Pixel Mapping:}
\begin{itemize}
    \item Sử dụng \textbf{2D block} và \textbf{2D grid} để map trực tiếp với ảnh 2D
    \item Thread ID được tính toán từ 2 chiều: \texttt{x = blockIdx.x * blockDim.x + threadIdx.x} và \texttt{y = blockIdx.y * blockDim.y + threadIdx.y}
    \item \texttt{blockIdx.x/y}: Chỉ số block trong grid (theo chiều X và Y)
    \item \texttt{blockDim.x/y}: Kích thước block (16x16)
    \item \texttt{threadIdx.x/y}: Chỉ số thread trong block (0-15)
    \item Kết quả: Mỗi thread biết chính xác pixel (x, y) mà nó phải xử lý
\end{itemize}

\textbf{3. Block Configuration:}
\begin{itemize}
    \item \textbf{Block size:} 16x16 = 256 threads per block
    \begin{itemize}
        \item Phù hợp với hầu hết GPU hiện đại
        \item Đạt occupancy tốt (số thread active / số thread tối đa)
        \item Cân bằng giữa parallelism và resource usage
        \item 256 threads = 8 warps (mỗi warp = 32 threads)
    \end{itemize}
    
    \item \textbf{Grid size:} Tính toán để bao phủ toàn bộ ảnh: \texttt{dim3 block(16, 16)} và \texttt{dim3 grid((width + block.x - 1) / block.x, (height + block.y - 1) / block.y)}
    \begin{itemize}
        \item Sử dụng công thức: $\lceil size / block\_size \rceil$ (ceiling division)
        \item Ví dụ: Ảnh 800x600 → Grid = (50, 38) blocks
        \item Tổng số blocks: 50 × 38 = 1,900 blocks
        \item Tổng số threads: 1,900 × 256 = 486,400 threads
        \item Đảm bảo tất cả pixels đều được xử lý (có thể dư một số threads)
    \end{itemize}
\end{itemize}

\textbf{4. Boundary Checking:}
\begin{itemize}
    \item Các threads ở biên ảnh hoặc ngoài phạm vi sẽ tự động return với điều kiện: \texttt{if (x <= 0 || y <= 0 || x >= width - 1 || y >= height - 1) return;}
    \item Lý do: Sobel kernel 3x3 cần các pixel lân cận, không thể tính cho pixel ở biên
    \item Các threads này vẫn được launch nhưng return ngay lập tức (overhead nhỏ)
    \item Output đã được khởi tạo = 0, nên pixel biên sẽ giữ nguyên giá trị 0
\end{itemize}

\textbf{5. Memory Access Pattern:}
\begin{itemize}
    \item Mỗi thread truy cập:
    \begin{itemize}
        \item \textbf{9 pixels từ input:} 3x3 neighborhood (p00, p01, p02, p10, p11, p12, p20, p21, p22)
        \item \textbf{1 pixel vào output:} Ghi kết quả magnitude
        \item Tổng cộng: \textbf{10 memory accesses per thread}
    \end{itemize}
    
    \item \textbf{Memory coalescing:}
    \begin{itemize}
        \item Các threads trong cùng một warp (32 threads) có thể truy cập memory liên tiếp
        \item GPU có thể hợp nhất (coalesce) các memory requests thành một transaction lớn
        \item Tuy nhiên, trong Sobel kernel:
        \begin{itemize}
            \item Mỗi thread cần 3 dòng khác nhau (y-1, y, y+1)
            \item Các threads trong cùng warp có thể ở các dòng khác nhau
            \item Memory access không hoàn toàn coalesced
            \item Vẫn hiệu quả vì GPU có cache và memory bandwidth cao
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Global memory access:}
    \begin{itemize}
        \item Code hiện tại truy cập trực tiếp global memory
        \item Không sử dụng shared memory (có thể cải thiện trong tương lai)
        \item Mỗi thread load 9 pixels độc lập từ global memory
    \end{itemize}
\end{itemize}

\textbf{6. Execution Flow:}
\begin{enumerate}
    \item \textbf{Launch:} CPU launch kernel với grid và block configuration
    \item \textbf{Distribution:} GPU scheduler phân phối các blocks cho các SMs (Streaming Multiprocessors)
    \item \textbf{Execution:} Mỗi SM chạy nhiều warps song song
    \item \textbf{Parallelism:} Hàng nghìn threads chạy đồng thời trên GPU
    \item \textbf{Completion:} Tất cả threads hoàn thành, GPU báo hiệu CPU
\end{enumerate}

\textbf{7. Ưu điểm của chiến thuật này:}
\begin{itemize}
    \item \textbf{Đơn giản:} Code dễ hiểu, dễ maintain
    \item \textbf{Hiệu quả:} Tận dụng tối đa số lượng threads của GPU
    \item \textbf{Scalable:} Tự động scale với kích thước ảnh
    \item \textbf{Load balancing:} GPU scheduler tự động cân bằng tải giữa các SMs
\end{itemize}

\textbf{8. Warp Execution và SIMT (Single Instruction Multiple Thread):}
\begin{itemize}
    \item \textbf{Warp:} 32 threads được nhóm lại thành một warp, thực thi cùng một instruction đồng thời
    \item \textbf{SIMT Model:} Mỗi thread trong warp có thể thực thi cùng instruction nhưng trên dữ liệu khác nhau
    \item \textbf{Divergence:} Nếu các threads trong warp đi theo các nhánh khác nhau (ví dụ: boundary check), GPU phải thực thi tuần tự từng nhánh
    \item \textbf{Trong Sobel kernel:} Boundary check có thể gây divergence, nhưng overhead nhỏ vì chỉ ảnh hưởng đến các threads ở biên
    \item \textbf{Warp efficiency:} Với block 16x16 = 256 threads = 8 warps, hầu hết warps không có divergence (chỉ warps ở biên ảnh)
\end{itemize}

\textbf{9. Memory Hierarchy và Access Pattern Chi Tiết:}
\begin{itemize}
    \item \textbf{Global Memory:}
    \begin{itemize}
        \item Bandwidth: Rất cao (hàng trăm GB/s) nhưng latency lớn (400-800 cycles)
        \item Mỗi thread load 9 pixels từ 3 dòng khác nhau: \texttt{row0[y-1]}, \texttt{row1[y]}, \texttt{row2[y+1]}
        \item Access pattern: Các threads trong cùng warp có thể truy cập các dòng khác nhau
        \item Cache: GPU có L1 và L2 cache để giảm latency
        \item Cache hit rate: Tốt vì các threads lân cận truy cập pixels gần nhau
    \end{itemize}
    
    \item \textbf{Shared Memory (chưa sử dụng, nhưng có tiềm năng):}
    \begin{itemize}
        \item Bandwidth: Rất cao (1-2 TB/s), latency thấp (~20 cycles)
        \item Có thể cache các dòng ảnh được dùng nhiều lần bởi các threads trong cùng block
        \item Với block 16x16, mỗi thread cần 3 dòng → có thể cache 18 dòng (16 + 2 border)
        \item Giảm global memory access từ 9 lần xuống còn 1-2 lần (chỉ load border)
        \item Tuy nhiên, với Sobel 3x3, overhead của shared memory có thể không đáng kể
    \end{itemize}
    
    \item \textbf{Register Memory:}
    \begin{itemize}
        \item Nhanh nhất (1 cycle), nhưng giới hạn số lượng
        \item Mỗi thread sử dụng: 9 pixel values (p00-p22), 2 gradients (gx, gy), 1 magnitude
        \item Tổng cộng: ~12-15 registers per thread
        \item Với block 16x16, tổng registers = 256 × 15 = 3,840 registers
        \item Hầu hết GPU có 65,536 registers per SM → đủ cho nhiều blocks
    \end{itemize}
    
    \item \textbf{Constant Memory:}
    \begin{itemize}
        \item Có thể lưu Sobel kernel coefficients (-1, -2, 0, 1, 2) trong constant memory
        \item Được cache và broadcast đến tất cả threads → rất hiệu quả
        \item Tuy nhiên, với chỉ 5 giá trị, overhead không đáng kể
    \end{itemize}
\end{itemize}

\textbf{10. Occupancy và Resource Utilization:}
\begin{itemize}
    \item \textbf{Occupancy:} Tỷ lệ số warps active trên số warps tối đa của một SM
    \item \textbf{Block size 16x16:} 256 threads = 8 warps per block
    \item \textbf{Giả sử GPU có 32 warps per SM:} Có thể chạy 4 blocks đồng thời = 32 warps = 100\% occupancy
    \item \textbf{Register pressure:} Với 15 registers/thread, 256 threads/block = 3,840 registers/block
    \item \textbf{Shared memory:} Không sử dụng → không có giới hạn từ shared memory
    \item \textbf{Kết quả:} Occupancy cao → GPU được sử dụng hiệu quả
\end{itemize}

\textbf{11. Instruction-Level Parallelism (ILP):}
\begin{itemize}
    \item \textbf{Pipeline:} GPU có pipeline sâu để che giấu latency
    \item \textbf{Multiple warps:} Khi một warp đợi memory, các warp khác tiếp tục thực thi
    \item \textbf{Trong Sobel kernel:}
    \begin{itemize}
        \item Load 9 pixels: Có thể được pipeline với các instructions khác
        \item Tính gradient: Các phép nhân và cộng có thể được thực thi song song
        \item Tính magnitude: \texttt{sqrtf()} có latency cao nhưng được che giấu bởi các warps khác
    \end{itemize}
    \item \textbf{Latency hiding:} Với nhiều warps active, memory latency được che giấu hoàn toàn
\end{itemize}

\textbf{12. Grid và Block Scheduling:}
\begin{itemize}
    \item \textbf{Block scheduling:} GPU scheduler phân phối blocks cho các SMs dựa trên tài nguyên có sẵn
    \item \textbf{Dynamic scheduling:} Khi một block hoàn thành, scheduler tự động gán block tiếp theo
    \item \textbf{Load balancing:} Tự động cân bằng tải giữa các SMs
    \item \textbf{Với ảnh 800x600:} Grid = (50, 38) = 1,900 blocks
    \item \textbf{Giả sử GPU có 10 SMs:} Mỗi SM xử lý ~190 blocks
    \item \textbf{Parallel execution:} Tất cả SMs chạy song song, xử lý nhiều blocks đồng thời
\end{itemize}

\textbf{13. Performance Analysis Chi Tiết:}
\begin{itemize}
    \item \textbf{Memory bandwidth utilization:}
    \begin{itemize}
        \item Mỗi thread: 9 reads + 1 write = 10 bytes
        \item 480,000 threads: 4.8 MB input + 0.48 MB output = 5.28 MB total
        \item Với thời gian 0.494 ms: Bandwidth = 5.28 MB / 0.494 ms = ~10.7 GB/s
        \item GPU hiện đại có bandwidth 100-900 GB/s → chỉ sử dụng ~1-10\% bandwidth
        \item Kết luận: Không bị giới hạn bởi memory bandwidth
    \end{itemize}
    
    \item \textbf{Compute intensity:}
    \begin{itemize}
        \item Mỗi pixel: 2 phép nhân (2×), 8 phép cộng/trừ, 1 phép nhân (gx², gy²), 1 phép cộng, 1 sqrt
        \item Tổng: ~13 operations per pixel
        \item 480,000 pixels: ~6.24 M operations
        \item Với 0.494 ms: ~12.6 GFLOPs
        \item GPU hiện đại có thể đạt 10-100 TFLOPs → compute không phải bottleneck
    \end{itemize}
    
    \item \textbf{Bottleneck:} Có thể là overhead của kernel launch, memory transfer, hoặc synchronization
\end{itemize}

\textbf{14. Tối ưu hóa tiềm năng:}
\begin{itemize}
    \item \textbf{Shared Memory Optimization:}
    \begin{itemize}
        \item Cache các dòng ảnh trong shared memory
        \item Giảm global memory access từ 9 lần xuống còn 1-2 lần
        \item Có thể tăng tốc 1.5-2x cho một số trường hợp
        \item Tuy nhiên, cần synchronization (\_\_syncthreads()) và phức tạp hơn
    \end{itemize}
    
    \item \textbf{Texture Memory:}
    \begin{itemize}
        \item Có cache 2D, phù hợp cho image processing
        \item Automatic boundary handling
        \item Có thể đơn giản hóa code và tăng hiệu năng
    \end{itemize}
    
    \item \textbf{Multiple CUDA Streams:}
    \begin{itemize}
        \item Overlap memory transfer với computation
        \item Upload frame N+1 trong khi xử lý frame N
        \item Download frame N-1 trong khi xử lý frame N
        \item Có thể tăng throughput pipeline
    \end{itemize}
    
    \item \textbf{Fused Operations:}
    \begin{itemize}
        \item Kết hợp nhiều operations trong một kernel
        \item Ví dụ: Sobel + normalization trong một kernel
        \item Giảm số lần truy cập memory
    \end{itemize}
\end{itemize}

\textbf{15. Hạn chế và trade-offs:}
\begin{itemize}
    \item \textbf{Boundary threads overhead:} Một số threads không làm việc, nhưng overhead nhỏ (<1\%)
    \item \textbf{Memory access không hoàn toàn coalesced:} Do cần 3 dòng khác nhau, nhưng vẫn hiệu quả nhờ cache
    \item \textbf{Không sử dụng shared memory:} Có thể cải thiện nhưng phức tạp hơn
    \item \textbf{Single kernel launch:} Không overlap transfer với computation
    \item \textbf{Đơn giản vs tối ưu:} Code hiện tại ưu tiên đơn giản, có thể tối ưu thêm nếu cần
\end{itemize}

\subsection{So sánh các phương pháp}

\subsubsection{Performance comparison}

Dựa trên benchmark với ảnh 800x600 pixels (0.48 MP):

\begin{table}[H]
\centering
\caption{So sánh chi tiết các phương pháp song song hóa}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Phương pháp} & \textbf{Thời gian} & \textbf{Speedup} & \textbf{FPS} & \textbf{Parallelism} \\
\hline
CPU Scalar & 7.144 ms & 1.0x & 140.0 & 1 thread \\
\hline
CPU OpenMP & ~7.144 ms & ~1.0x & ~140.0 & Multi-thread \\
\hline
GPU CUDA & 0.494 ms & 14.47x & 2025.5 & Thousands threads \\
\hline
\end{tabular}
\end{table}

\subsubsection{Phân tích chi tiết}

\textbf{CUDA vs CPU Scalar:}
\begin{itemize}
    \item CUDA nhanh hơn 14.47x nhờ tận dụng hàng nghìn cores của GPU
    \item GPU có parallelism ở nhiều tầng: threads, warps, blocks, SMs
    \item Memory bandwidth của GPU cao hơn CPU nhiều lần
    \item Overhead memory transfer được che giấu bởi parallelism
\end{itemize}

\textbf{Ưu điểm của CUDA:}
\begin{itemize}
    \item \textbf{Parallelism massive:} Hàng trăm nghìn threads chạy đồng thời
    \item \textbf{Memory bandwidth cao:} GPU có bandwidth 100-900 GB/s vs CPU ~50 GB/s
    \item \textbf{Latency hiding:} Nhiều warps che giấu memory latency
    \item \textbf{Scalable:} Tự động scale với kích thước ảnh và số lượng SMs
\end{itemize}

\section{Tích hợp Sobel vào pipeline AI}

\subsection{Sobel trước model}

Bộ lọc Sobel được áp dụng trước khi đưa vào mô hình detection để:
\begin{itemize}
    \item Tăng cường thông tin biên của biển số
    \item Giảm nhiễu và các chi tiết không liên quan
    \item Tạo đặc trưng đầu vào tốt hơn cho mô hình
\end{itemize}

\subsection{Chuẩn hóa ảnh}

Sau khi áp dụng Sobel, ảnh được chuẩn hóa:
\begin{itemize}
    \item Chuyển đổi sang grayscale nếu cần
    \item Normalize giá trị pixel về khoảng [0, 1] hoặc [-1, 1]
    \item Resize về kích thước input của model (640x640 cho detection)
\end{itemize}

\subsection{Resize phù hợp input model}

Model YOLOv5 yêu cầu input kích thước cố định (640x640). Pipeline tự động resize ảnh với giữ nguyên tỷ lệ khung hình và thêm padding nếu cần.

\section{Mô hình phát hiện biển số}

\subsection{Cấu trúc model}

Model detection sử dụng YOLOv5-nano với cấu trúc:
\begin{itemize}
    \item Input layer: 640x640x3 (RGB)
    \item Backbone: CSPDarknet53 với các lớp convolution và residual blocks
    \item Neck: PANet để tổng hợp đặc trưng đa tỷ lệ
    \item Head: Detection head với 3 scale (small, medium, large objects)
\end{itemize}

\subsection{Input shape}

\begin{itemize}
    \item Kích thước: 640x640 pixels
    \item Channels: 3 (RGB)
    \item Data type: Float32, giá trị normalized [0, 1]
\end{itemize}

\subsection{Output bounding box}

Model trả về:
\begin{itemize}
    \item Tọa độ bounding box: $(x_{center}, y_{center}, width, height)$ hoặc $(x_1, y_1, x_2, y_2)$
    \item Confidence score: Độ tin cậy của detection (0-1)
    \item Class ID: ID của lớp (biển số)
\end{itemize}

\subsection{Tham số huấn luyện}

Model được huấn luyện với:
\begin{itemize}
    \item Dataset: Tập dữ liệu biển số xe Việt Nam
    \item Models: \texttt{bestDetect.pt} (detection) và \texttt{bestOCR.pt} (OCR) - các checkpoint tốt nhất từ quá trình huấn luyện
    \item Export: Models được export từ PyTorch (.pt) sang ONNX (.onnx) format để sử dụng với ONNX Runtime
    \item Batch size: Phụ thuộc vào GPU memory
    \item Learning rate: Sử dụng learning rate schedule của YOLOv5
    \item Augmentation: Random flip, color jitter, mosaic, mixup
\end{itemize}

\section{Luồng xử lý tổng thể}

\subsection{Chiến thuật Task Parallelism}

Đề tài sử dụng \textbf{Pipeline Parallelism} (hay còn gọi là Task Parallelism) để song song hóa các giai đoạn xử lý khác nhau của pipeline. Đây là chiến thuật song song hóa ở mức độ cao, trong đó các task khác nhau được thực hiện đồng thời trên các thread riêng biệt.

\subsubsection{Kiến trúc Pipeline với 5 Threads}

Hệ thống được thiết kế với \textbf{5 threads độc lập}, mỗi thread chịu trách nhiệm một giai đoạn xử lý cụ thể:

\begin{enumerate}
    \item \textbf{Thread 1 - Capture:} Đọc frame từ camera/file và đưa vào queue
    \item \textbf{Thread 2 - Sobel:} Áp dụng bộ lọc Sobel với tối ưu song song
    \item \textbf{Thread 3 - Detection:} Chạy model YOLOv5 để phát hiện biển số
    \item \textbf{Thread 4 - OCR:} Nhận dạng ký tự từ các vùng biển số đã phát hiện
    \item \textbf{Thread 5 - Render:} Vẽ kết quả và hiển thị lên màn hình
\end{enumerate}

\subsubsection{Thread-Safe Queue (TSQueue)}

Để truyền dữ liệu giữa các threads một cách an toàn, hệ thống sử dụng \textbf{Thread-Safe Queue} (TSQueue):

\textbf{Cấu trúc TSQueue:} TSQueue là template class sử dụng \texttt{std::mutex} và \texttt{std::condition\_variable} để đồng bộ, \texttt{std::queue} để chứa dữ liệu, và có kích thước tối đa (5 frames). Các phương thức chính: \texttt{push()} để thêm vào queue, \texttt{pop()} để lấy ra, và \texttt{empty()} để kiểm tra rỗng.

\textbf{Đặc điểm:}
\begin{itemize}
    \item \textbf{Thread-safe:} Sử dụng mutex và condition variable để đảm bảo an toàn khi nhiều threads truy cập
    \item \textbf{Bounded buffer:} Giới hạn tối đa 5 frames trong mỗi queue để tránh tràn bộ nhớ
    \item \textbf{Blocking push:} Nếu queue đầy, thread sẽ đợi cho đến khi có chỗ trống
    \item \textbf{Non-blocking pop:} Nếu queue rỗng, thread sẽ return false và tiếp tục vòng lặp
\end{itemize}

\textbf{5 Queues trong hệ thống:}
\begin{itemize}
    \item \texttt{qCapture\_}: Capture → Sobel (buffer 5 frames)
    \item \texttt{qSobel\_}: Sobel → Detection (buffer 5 frames)
    \item \texttt{qDetect\_}: Detection → OCR (buffer 5 frames)
    \item \texttt{qOCR\_}: OCR → Render (buffer 5 frames)
    \item \texttt{qRender\_}: Render (buffer 5 frames)
\end{itemize}

\subsubsection{Chi tiết từng Thread}

\textbf{1. Capture Thread (\texttt{captureLoop}):}
\begin{itemize}
    \item \textbf{Nhiệm vụ:} Đọc frame từ camera hoặc file ảnh/video
    \item \textbf{Input:} Camera stream hoặc file path
    \item \textbf{Output:} FramePacket chứa frame gốc, đẩy vào \texttt{qCapture\_}
    \item \textbf{Đặc điểm:}
    \begin{itemize}
        \item Hỗ trợ cả camera (V4L2) và file ảnh/video
        \item Tự động xử lý lỗi khi không đọc được frame
        \item Đếm số frame để tracking
    \end{itemize}
\end{itemize}

\textbf{2. Sobel Thread (\texttt{sobelLoop}):}
\begin{itemize}
    \item \textbf{Nhiệm vụ:} Áp dụng bộ lọc Sobel với tối ưu song song (CUDA)
    \item \textbf{Input:} FramePacket từ \texttt{qCapture\_}
    \item \textbf{Output:} FramePacket với ảnh Sobel, đẩy vào \texttt{qSobel\_}
    \item \textbf{Đặc điểm:}
    \begin{itemize}
        \item Tự động chuyển đổi sang grayscale nếu cần
        \item Sử dụng CUDA (bắt buộc)
        \item Xử lý độc lập, không block các thread khác
    \end{itemize}
\end{itemize}

\textbf{3. Detection Thread (\texttt{detectLoop}):}
\begin{itemize}
    \item \textbf{Nhiệm vụ:} Chạy YOLOv5 model để phát hiện vùng biển số
    \item \textbf{Input:} FramePacket từ \texttt{qSobel\_} (chứa frame gốc)
    \item \textbf{Output:} FramePacket với danh sách bounding boxes, đẩy vào \texttt{qDetect\_}
    \item \textbf{Đặc điểm:}
    \begin{itemize}
        \item Chỉ làm detection, không làm OCR (tách riêng để song song hóa)
        \item Sử dụng ONNX Runtime để inference
        \item Trả về vector các cv::Rect chứa vùng biển số
    \end{itemize}
    \item \textbf{Lợi ích tách riêng:} Detection và OCR có thể chạy song song trên các frame khác nhau
\end{itemize}

\textbf{4. OCR Thread (\texttt{ocrLoop}):}
\begin{itemize}
    \item \textbf{Nhiệm vụ:} Nhận dạng ký tự từ các vùng biển số đã phát hiện
    \item \textbf{Input:} FramePacket từ \texttt{qDetect\_} (chứa frame + bounding boxes)
    \item \textbf{Output:} FramePacket với text biển số, đẩy vào \texttt{qRender\_}
    \item \textbf{Đặc điểm:}
    \begin{itemize}
        \item Xử lý nhiều ROI song song nếu có nhiều biển số (Data Parallelism)
        \item Sử dụng OpenMP để song song hóa các ROI:
        Sử dụng \texttt{\#pragma omp parallel for} để xử lý nhiều ROI song song, mỗi ROI được nhận dạng độc lập.
        \item Ghép kết quả từ nhiều biển số (lấy biển số đầu tiên có text)
    \end{itemize}
    \item \textbf{Kết hợp Task + Data Parallelism:} Thread riêng (Task) + OpenMP cho nhiều ROI (Data)
\end{itemize}

\textbf{5. Render Thread (\texttt{renderLoop}):}
\begin{itemize}
    \item \textbf{Nhiệm vụ:} Vẽ kết quả lên frame và hiển thị
    \item \textbf{Input:} FramePacket từ \texttt{qOCR\_} (chứa frame + boxes + text)
    \item \textbf{Output:} Hiển thị lên cửa sổ OpenCV
    \item \textbf{Đặc điểm:}
    \begin{itemize}
        \item Vẽ bounding boxes màu xanh cho các biển số phát hiện được
        \item Hiển thị text biển số trên frame
        \item Hiển thị FPS và thông tin frame
    \end{itemize}
\end{itemize}

\subsubsection{Pipeline Overlap và Throughput}

\textbf{Khái niệm Pipeline Overlap:}
\begin{itemize}
    \item Các frame khác nhau được xử lý ở các giai đoạn khác nhau \textbf{cùng lúc}
    \item Ví dụ: Frame N đang ở Detection, Frame N+1 đang ở Sobel, Frame N+2 đang ở Capture
    \item Điều này tăng \textbf{throughput} (số frame xử lý được mỗi giây)
\end{itemize}

\textbf{Ví dụ minh họa:} Tại thời điểm T0, chỉ có Capture đang xử lý Frame 0. Tại T1, Capture xử lý Frame 1 trong khi Sobel xử lý Frame 0. Tại T2, Capture xử lý Frame 2, Sobel xử lý Frame 1, và Detection xử lý Frame 0. Quá trình này tiếp tục cho đến khi tất cả các stage đều có frame để xử lý, tạo ra pipeline overlap và tăng throughput.

\textbf{Lợi ích:}
\begin{itemize}
    \item \textbf{Tăng throughput:} Nhiều frame được xử lý đồng thời
    \item \textbf{Tận dụng tài nguyên:} CPU/GPU được sử dụng liên tục, không idle
    \item \textbf{Giảm latency tổng thể:} Mặc dù latency của một frame không đổi, nhưng latency trung bình giảm do pipeline overlap
\end{itemize}

\subsubsection{Tách Detection và OCR thành 2 Threads riêng}

\textbf{Lý do tách riêng:}
\begin{itemize}
    \item \textbf{Độc lập về dữ liệu:} Detection và OCR có thể chạy trên các frame khác nhau
    \item \textbf{Tận dụng CPU tốt hơn:} Nếu có nhiều cores, Detection và OCR có thể chạy song song
    \item \textbf{Giảm blocking:} OCR không phải đợi Detection hoàn thành frame hiện tại
\end{itemize}

\textbf{So sánh trước và sau:}

\textbf{Trước (Detection + OCR cùng thread):} Hệ thống có 4 threads: Capture, Sobel, Detect+OCR (tuần tự), và Render. OCR phải đợi Detection hoàn thành mới bắt đầu.
\begin{itemize}
    \item OCR phải đợi Detection xong mới bắt đầu
    \item Nếu Detection mất 50ms và OCR mất 30ms → Tổng 80ms cho 1 frame
\end{itemize}

\textbf{Sau (Detection và OCR tách riêng):} Hệ thống có 5 threads độc lập: Capture, Sobel, Detection (chỉ detect), OCR (chỉ OCR), và Render. Detection và OCR chạy song song trên các frame khác nhau.
\begin{itemize}
    \item Detection và OCR chạy song song trên các frame khác nhau
    \item Pipeline có thể xử lý nhiều frame cùng lúc
    \item Throughput tăng đáng kể
\end{itemize}

\subsubsection{Điều kiện dừng và Synchronization}

\textbf{Điều kiện dừng:}
\begin{itemize}
    \item Mỗi thread chạy trong vòng lặp \texttt{while} với điều kiện: \texttt{while (running\_.load() || !qInput\_.empty())} để tiếp tục xử lý frame cho đến khi người dùng dừng và queue rỗng.
    \item Thread sẽ dừng khi:
    \begin{itemize}
        \item \texttt{running\_} = false (người dùng dừng)
        \item VÀ queue input rỗng (đã xử lý hết frame)
    \end{itemize}
    \item Đảm bảo tất cả frame được xử lý trước khi dừng
\end{itemize}

\textbf{Synchronization:}
\begin{itemize}
    \item Sử dụng \texttt{std::atomic<bool>} cho flag \texttt{running\_}
    \item TSQueue tự động đồng bộ bằng mutex và condition variable
    \item \texttt{join()} để đợi tất cả threads hoàn thành
\end{itemize}

\subsubsection{Ưu điểm của Task Parallelism}

\textbf{1. Tăng Throughput:}
\begin{itemize}
    \item Nhiều frame được xử lý đồng thời ở các giai đoạn khác nhau
    \item Tận dụng tối đa tài nguyên CPU/GPU
    \item Có thể đạt throughput cao hơn nhiều so với sequential processing
\end{itemize}

\textbf{2. Giảm Latency:}
\begin{itemize}
    \item Mặc dù latency của một frame không đổi, nhưng latency trung bình giảm
    \item Frame mới không phải đợi frame cũ hoàn thành hoàn toàn
    \item Pipeline overlap giúp giảm thời gian chờ đợi
\end{itemize}

\textbf{3. Scalability:}
\begin{itemize}
    \item Dễ dàng thêm/bớt các giai đoạn xử lý
    \item Mỗi giai đoạn độc lập, có thể tối ưu riêng
    \item Có thể mở rộng với nhiều threads hơn nếu cần
\end{itemize}

\textbf{4. Resource Utilization:}
\begin{itemize}
    \item CPU cores được sử dụng hiệu quả
    \item GPU có thể được sử dụng cho Sobel và Detection cùng lúc (nếu có)
    \item Tránh idle time giữa các giai đoạn
\end{itemize}

\subsubsection{Hạn chế và Trade-offs}

\textbf{1. Memory Overhead:}
\begin{itemize}
    \item Cần lưu trữ nhiều frame trong pipeline (tối đa 5 frames × 5 queues = 25 frames)
    \item Mỗi frame có thể lớn (ví dụ: 1920×1080×3 bytes = 6MB)
    \item Tổng memory: 25 × 6MB = 150MB chỉ cho buffers
\end{itemize}

\textbf{2. Complexity:}
\begin{itemize}
    \item Code phức tạp hơn so với sequential processing
    \item Cần quản lý threads, queues, synchronization
    \item Khó debug hơn do nhiều threads chạy đồng thời
\end{itemize}

\textbf{3. Latency của một frame:}
\begin{itemize}
    \item Latency của một frame cụ thể không giảm (vẫn phải đi qua tất cả các giai đoạn)
    \item Chỉ có latency trung bình giảm nhờ pipeline overlap
\end{itemize}

\textbf{4. Synchronization Overhead:}
\begin{itemize}
    \item Mutex và condition variable có overhead
    \item Queue operations có thể block threads
    \item Tuy nhiên, overhead này nhỏ so với lợi ích
\end{itemize}

\subsection{Sơ đồ khối hệ thống}

Hệ thống sử dụng kiến trúc pipeline với 5 threads độc lập và các queue thread-safe để truyền dữ liệu giữa các stage:

\begin{itemize}
    \item \textbf{Thread 1 - Capture:} Đọc frame từ camera/file và đưa vào qCapture\_
    \item \textbf{Thread 2 - Sobel:} Lấy frame từ qCapture\_, áp dụng Sobel, đưa vào qSobel\_
    \item \textbf{Thread 3 - Detection:} Lấy frame từ qSobel\_, chạy detection model, đưa vào qDetect\_
    \item \textbf{Thread 4 - OCR:} Lấy frame từ qDetect\_, cắt ROI và chạy OCR cho tất cả biển số song song, đưa vào qOCR\_
    \item \textbf{Thread 5 - Render:} Lấy frame từ qOCR\_, vẽ bounding box và text, hiển thị kết quả
\end{itemize}

\subsection{Trình tự xử lý dữ liệu}

Mỗi frame đi qua các bước sau:

\begin{enumerate}
    \item \textbf{Capture:} Frame được đọc và đóng gói vào FramePacket
    \item \textbf{Sobel:} Áp dụng Sobel filter với CUDA
    \item \textbf{Preprocessing:} Resize, normalize, chuyển đổi format cho model
    \item \textbf{Detection:} Chạy YOLOv5 detection model qua ONNX Runtime
    \item \textbf{Post-processing:} NMS (Non-Maximum Suppression) để loại bỏ duplicate detections
    \item \textbf{OCR:} Với mỗi bounding box, cắt ROI và chạy OCR model (song song nếu có nhiều biển số)
    \item \textbf{Render:} Vẽ kết quả lên frame và hiển thị
\end{enumerate}

\chapter{CÀI ĐẶT VÀ THỰC NGHIỆM}

\section{Môi trường thực nghiệm}

\subsection{Phần cứng}

\textbf{CPU:} Processor đa lõi để chạy pipeline với 5 threads.

\textbf{GPU:} NVIDIA GPU với CUDA support. Trong thực nghiệm, hệ thống sử dụng GPU NVIDIA Quadro K2100M với CUDA toolkit. Hệ thống bắt buộc phải có GPU NVIDIA để chạy.

\textbf{Bộ nhớ:} RAM đủ để xử lý ảnh và load model ONNX vào memory. Pipeline với 5 queues, mỗi queue buffer 5 frames, yêu cầu bộ nhớ đáng kể cho video độ phân giải cao.

\subsection{Phần mềm}

\textbf{Programming Language:} C++17 với các thư viện:
\begin{itemize}
    \item OpenCV 4.x: Xử lý ảnh cơ bản, I/O, camera interface
    \item ONNX Runtime 1.16.3: Chạy inference cho YOLOv5 models, được đặt tại \texttt{/tmp/onnxruntime-linux-x64-1.16.3}
    \item OpenMP: Song song hóa đa luồng trên CPU
    \item CUDA Toolkit (nếu có GPU): Compile và chạy CUDA kernels, yêu cầu nvcc compiler
\end{itemize}

\textbf{Framework AI:} ONNX Runtime cho inference, models được export từ PyTorch (YOLOv5) sang ONNX format. Models sử dụng:
\begin{itemize}
    \item Detection model: \texttt{models/bestDetect.onnx} (YOLOv5-nano, được export từ \texttt{bestDetect.pt})
    \item OCR model: \texttt{models/bestOCR.onnx} (YOLOv5-nano, được export từ \texttt{bestOCR.pt})
\end{itemize}

\textbf{Build System:} Có 3 script build riêng cho từng phương pháp:
\begin{itemize}
    \item \texttt{build.sh}: Build với CUDA (nếu có GPU), tự động detect CUDA architecture
    \item \texttt{build\_simd.sh}: Build với SIMD + OpenMP (không CUDA)
    \item \texttt{build\_openmp.sh}: Build chỉ với OpenMP (scalar, không SIMD, không CUDA)
\end{itemize}

\textbf{Flags compile:}
\begin{itemize}
    \item \texttt{-std=c++17}: C++ standard
    \item \texttt{-fopenmp}: Bật OpenMP cho multi-threading
    \item \texttt{-mavx2}: Bật AVX-256 instructions cho SIMD (chỉ trong build\_simd.sh)
    \item \texttt{-DUSE\_CUDA\_SOBEL}: Macro để bật CUDA support (chỉ trong build.sh)
    \item \texttt{-DUSE\_SIMD\_SOBEL}: Macro để bật SIMD support (chỉ trong build\_simd.sh)
\end{itemize}

\textbf{Cấu trúc dự án:}
\begin{itemize}
    \item \texttt{src/}: Source code C++ (.cpp, .cu)
    \begin{itemize}
        \item \texttt{main.cpp}: Entry point, khởi tạo Pipeline
        \item \texttt{Pipeline.cpp}: Pipeline với 5 threads (Capture, Sobel, Detect, OCR, Render)
        \item \texttt{LPDetector.cpp}: Detection model wrapper
        \item \texttt{LPOCR.cpp}: OCR model wrapper
        \item \texttt{SobelCuda.cu}: CUDA kernel cho Sobel filter
        \item \texttt{SobelSIMD.cpp}: SIMD implementation cho Sobel filter
    \end{itemize}
    \item \texttt{include/}: Header files (.h)
    \begin{itemize}
        \item \texttt{Pipeline.h}: Pipeline class với TSQueue và FramePacket
        \item \texttt{LPDetector.h}, \texttt{LPOCR.h}: Model wrappers
        \item \texttt{SobelCuda.h}, \texttt{SobelSIMD.h}: Sobel implementations
    \end{itemize}
    \item \texttt{scripts/}: Build scripts và utility scripts
    \begin{itemize}
        \item \texttt{build.sh}: Build với CUDA (chính)
        \item \texttt{build\_simd.sh}: Build với SIMD
        \item \texttt{build\_openmp.sh}: Build với OpenMP only
        \item \texttt{benchmark.sh}: Script benchmark so sánh các phương pháp
    \end{itemize}
    \item \texttt{models/}: Model files (.onnx, .pt)
    \begin{itemize}
        \item \texttt{bestDetect.onnx}, \texttt{bestOCR.onnx}: Models ONNX
        \item \texttt{bestDetect.pt}, \texttt{bestOCR.pt}: Models PyTorch gốc
    \end{itemize}
    \item Binary outputs: \texttt{lp\_main} (CUDA), \texttt{lp\_main\_simd}, \texttt{lp\_main\_openmp}
\end{itemize}

\section{Dataset}

\subsection{Nguồn dữ liệu}

Dataset được sử dụng để huấn luyện model detection và OCR:
\begin{itemize}
    \item Tập dữ liệu biển số xe Việt Nam
    \item Bao gồm nhiều điều kiện: ban ngày, ban đêm, nhiều góc chụp
    \item Đã được annotate với bounding boxes và text labels
\end{itemize}

\subsection{Số lượng ảnh}

\begin{itemize}
    \item Training set: Khoảng vài nghìn ảnh
    \item Validation set: Khoảng 20\% của training set
    \item Test set: Ảnh thực tế từ camera hoặc file
\end{itemize}

\subsection{Điều kiện chụp}

Dataset bao gồm các điều kiện đa dạng:
\begin{itemize}
    \item Ánh sáng: Ban ngày, ban đêm, bóng râm
    \item Góc chụp: Trực diện, nghiêng, từ trên xuống
    \item Khoảng cách: Gần, xa, độ phân giải khác nhau
    \item Môi trường: Trong nhà, ngoài trời, bãi đỗ xe
\end{itemize}

\section{Các kịch bản thực nghiệm}

\subsection{Không Sobel}

Baseline: Chạy detection model trực tiếp trên ảnh gốc không qua bộ lọc Sobel.

\textbf{Mục đích:} Đánh giá hiệu suất cơ bản của model không có tiền xử lý.

\subsection{Sobel đơn luồng}

Áp dụng bộ lọc Sobel với implementation scalar (không song song hóa).

\textbf{Mục đích:} Đo lường overhead của Sobel và so sánh với baseline.

\subsection{Sobel song song}

Áp dụng bộ lọc Sobel với các phương pháp song song hóa:

\textbf{CPU OpenMP (scalar):} Song song hóa theo dòng với OpenMP nhưng vẫn dùng code scalar.

\textbf{CPU SIMD (AVX-256):} Kết hợp OpenMP và SIMD vectorization, xử lý 8 pixels cùng lúc.

\textbf{GPU CUDA:} Triển khai CUDA kernel để xử lý song song trên GPU.

\section{Chỉ số đánh giá}

\subsection{Độ chính xác (Accuracy)}

\textbf{Precision:} Tỷ lệ các detection đúng trong tổng số detections:
\begin{equation}
Precision = \frac{TP}{TP + FP}
\end{equation}

\textbf{Recall:} Tỷ lệ các biển số thực tế được phát hiện:
\begin{equation}
Recall = \frac{TP}{TP + FN}
\end{equation}

\textbf{mAP (mean Average Precision):} Trung bình của Average Precision ở các ngưỡng IoU khác nhau.

\subsection{Thời gian xử lý}

\textbf{Latency:} Thời gian xử lý một frame từ đầu đến cuối (end-to-end latency).

\textbf{Throughput:} Số frame xử lý được trong một giây (FPS - Frames Per Second).

\subsection{FPS}

FPS được tính bằng:
\begin{equation}
FPS = \frac{1}{Latency_{avg}}
\end{equation}

Trong đó $Latency_{avg}$ là thời gian trung bình xử lý một frame.

\subsection{Latency}

Đo lường latency cho từng stage:
\begin{itemize}
    \item Sobel processing time
    \item Detection inference time
    \item OCR inference time
    \item Total pipeline latency
\end{itemize}

\section{Kết quả thực nghiệm}

\subsection{Bảng so sánh}

Dựa trên benchmark results từ file \texttt{benchmark\_results.txt}, kết quả cho ảnh 800x600 pixels (0.48 MP):

\begin{table}[H]
\centering
\caption{So sánh hiệu năng các phương pháp Sobel (100 runs average, ảnh 800x600 pixels, 0.48 MP)}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Phương pháp} & \textbf{Thời gian (ms)} & \textbf{Speedup} & \textbf{FPS} & \textbf{Tốc độ xử lý} \\
\hline
CPU OpenMP (scalar) & 7.144 & 1.0x (baseline) & 140.0 & ~140 MP/s \\
CPU SIMD (AVX-256) & 1.885 & 3.79x & 530.4 & ~530 MP/s \\
GPU CUDA & 0.494 & 14.47x & 2025.5 & ~2025 MP/s \\
\hline
\end{tabular}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{Image/BenchMark.png}
\caption{Kết quả benchmark so sánh hiệu năng các phương pháp song song hóa Sobel filter}
\label{fig:benchmark}
\end{figure}

\subsubsection{So sánh chi tiết giữa các phương pháp}

\begin{table}[H]
\centering
\caption{So sánh chi tiết giữa các phương pháp}
\begin{tabular}{|l|c|c|}
\hline
\textbf{So sánh} & \textbf{Tỷ lệ} & \textbf{Giải thích} \\
\hline
CUDA vs CPU scalar & 14.47x nhanh hơn & GPU có hàng nghìn cores vs CPU có vài cores \\
CUDA vs SIMD & 3.82x nhanh hơn & GPU parallelism vượt trội so với SIMD \\
SIMD vs CPU scalar & 3.79x nhanh hơn & SIMD xử lý 8 pixels cùng lúc \\
\hline
\end{tabular}
\end{table}

\subsection{Phân tích kết quả}

\textbf{CPU OpenMP (scalar):}
\begin{itemize}
    \item Thời gian: 7.144 ms/frame
    \item FPS: 140.0 FPS
    \item Tốc độ xử lý: ~140 MP/s (megapixels per second)
    \item Đánh giá: Baseline, đơn giản nhưng hiệu năng thấp nhất
\end{itemize}

\textbf{CPU SIMD (AVX-256):}
\begin{itemize}
    \item Thời gian: 1.885 ms/frame
    \item FPS: 530.4 FPS
    \item Speedup: 3.79x so với OpenMP
    \item Tốc độ xử lý: ~530 MP/s
    \item Đánh giá: Cải thiện đáng kể nhờ xử lý 8 pixels cùng lúc với AVX-256, không cần GPU
\end{itemize}

\textbf{GPU CUDA:}
\begin{itemize}
    \item Thời gian: 0.494 ms/frame
    \item FPS: 2025.5 FPS
    \item Speedup: 14.47x so với OpenMP, 3.82x so với SIMD
    \item Tốc độ xử lý: ~2025 MP/s
    \item Đánh giá: Nhanh nhất, phù hợp cho real-time với throughput cao, nhưng yêu cầu GPU NVIDIA
\end{itemize}

\textbf{Kết luận từ benchmark:}
\begin{itemize}
    \item SIMD vectorization cho thấy 3.79x cải thiện hiệu năng so với scalar code
    \item CUDA GPU cho thấy 14.47x cải thiện so với CPU scalar và 3.82x so với SIMD
    \item GPU CUDA là phương pháp nhanh nhất, phù hợp cho xử lý ảnh real-time với throughput cao
    \item Với ảnh 800x600 (0.48 MP), CUDA có thể xử lý hơn 2000 FPS, đủ cho nhiều ứng dụng real-time
\end{itemize}

\subsection{Biểu đồ hiệu năng}

\textbf{Biểu đồ thời gian xử lý:} (Có thể vẽ biểu đồ cột so sánh thời gian của 3 phương pháp)

\textbf{Biểu đồ FPS:} (Có thể vẽ biểu đồ cột so sánh FPS của 3 phương pháp)

\textbf{Biểu đồ speedup:} (Có thể vẽ biểu đồ cột so sánh speedup so với baseline)

\chapter{ĐÁNH GIÁ VÀ THẢO LUẬN}

\section{Phân tích kết quả}

\subsection{Sobel ảnh hưởng thế nào tới model}

\textbf{Tăng cường thông tin biên:} Bộ lọc Sobel làm nổi bật các cạnh và đường viền trong ảnh, đặc biệt là các đường thẳng ngang và dọc của biển số. Điều này giúp model dễ dàng phát hiện vùng biển số hơn.

\textbf{Giảm nhiễu:} Bằng cách tập trung vào thông tin biên, Sobel giúp loại bỏ các chi tiết không liên quan và nhiễu trong ảnh, tạo đầu vào "sạch" hơn cho model.

\textbf{Ảnh hưởng đến accuracy:} Tùy thuộc vào điều kiện ảnh, Sobel có thể cải thiện hoặc giảm độ chính xác. Với ảnh có nhiều nhiễu hoặc độ tương phản thấp, Sobel thường cải thiện kết quả. Tuy nhiên, với ảnh chất lượng tốt, Sobel có thể không cần thiết hoặc thậm chí làm mất một số thông tin màu sắc.

\subsection{Lợi ích song song hóa}

\textbf{Tăng throughput:} Song song hóa cho phép xử lý nhiều frame hơn trong cùng một khoảng thời gian. Với CUDA, có thể đạt hơn 2000 FPS cho Sobel filter, đủ cho nhiều ứng dụng real-time.

\textbf{Giảm latency:} Mặc dù latency của một frame có thể không giảm nhiều (do overhead), nhưng với pipeline parallelism, các frame có thể được xử lý chồng chéo, giảm latency tổng thể.

\textbf{Tận dụng tài nguyên:} Song song hóa tận dụng tối đa các lõi CPU và GPU, tăng hiệu quả sử dụng phần cứng.

\subsection{So sánh các phương pháp song song}

\textbf{CPU OpenMP (scalar):} Đơn giản, dễ triển khai, hoạt động trên mọi CPU đa lõi. Tuy nhiên, không tận dụng được SIMD units của CPU. Phù hợp cho prototype và development.

\textbf{CPU SIMD (AVX-256):} Cân bằng tốt giữa hiệu năng và tính tương thích. Không cần GPU, nhưng yêu cầu CPU hỗ trợ AVX2 (hầu hết CPU từ 2013+). Đạt speedup 3.79x so với scalar. Phù hợp cho hệ thống không có GPU nhưng cần hiệu năng tốt hơn OpenMP.

\textbf{GPU CUDA:} Nhanh nhất, phù hợp cho throughput cao. Đạt speedup 14.47x so với baseline và 3.82x so với SIMD. Tuy nhiên, yêu cầu GPU NVIDIA và có overhead khi transfer data giữa CPU-GPU. Phù hợp cho production system với yêu cầu real-time cao.

\subsubsection{Đánh giá theo các tiêu chí}

\textbf{Yêu cầu phần cứng:}
\begin{itemize}
    \item \textbf{OpenMP:} CPU đa nhân bất kỳ, không yêu cầu đặc biệt
    \item \textbf{SIMD:} CPU hỗ trợ AVX2 (~95\% CPU từ 2013+)
    \item \textbf{CUDA:} GPU NVIDIA với CUDA toolkit (~30-40\% hệ thống)
\end{itemize}

\textbf{Độ phức tạp triển khai:}
\begin{itemize}
    \item \textbf{OpenMP:} Dễ (1-2 giờ), chỉ cần thêm \texttt{\#pragma omp parallel for}
    \item \textbf{SIMD:} Trung bình (4-8 giờ), cần hiểu AVX intrinsics
    \item \textbf{CUDA:} Khó (1-2 ngày), cần hiểu GPU architecture và memory management
\end{itemize}

\textbf{Tiêu thụ tài nguyên:}
\begin{itemize}
    \item \textbf{OpenMP:} CPU usage cao (100\% cores), GPU 0\%, memory thấp
    \item \textbf{SIMD:} CPU usage cao (100\% cores), GPU 0\%, memory thấp
    \item \textbf{CUDA:} CPU usage thấp, GPU usage cao (80-100\%), memory trung bình (GPU memory)
\end{itemize}

\textbf{Khuyến nghị sử dụng:}
\begin{itemize}
    \item \textbf{Production với GPU:} Sử dụng CUDA để đạt hiệu năng tối đa
    \item \textbf{Production không có GPU:} Sử dụng SIMD để đạt hiệu năng tốt mà không cần GPU
    \item \textbf{Development/Testing:} Sử dụng OpenMP để đơn giản hóa development
\end{itemize}

\section{So sánh với phương pháp khác}

\subsection{Không tiền xử lý}

Pipeline không có Sobel sẽ:
\begin{itemize}
    \item Nhanh hơn (bỏ qua bước Sobel)
    \item Có thể kém chính xác hơn với ảnh nhiễu hoặc độ tương phản thấp
    \item Phụ thuộc hoàn toàn vào khả năng của model học sâu
\end{itemize}

\subsection{Tiền xử lý truyền thống}

Các phương pháp tiền xử lý khác có thể so sánh:
\begin{itemize}
    \item \textbf{Gaussian Blur:} Làm mờ để giảm nhiễu, nhưng có thể làm mất chi tiết
    \item \textbf{Histogram Equalization:} Cải thiện độ tương phản, nhưng có thể làm tăng nhiễu
    \item \textbf{Canny Edge Detection:} Tương tự Sobel nhưng phức tạp hơn, có thể chậm hơn
\end{itemize}

Sobel được chọn vì cân bằng tốt giữa hiệu năng và hiệu quả, dễ song song hóa.

\section{Hạn chế của đề tài}

\subsection{Quyết định triển khai CUDA}

Dựa trên kết quả benchmark, hệ thống đã quyết định sử dụng CUDA làm phương pháp chính cho Sobel filter:

\textbf{Lý do:}
\begin{itemize}
    \item Hiệu năng cao nhất: 14.47x so với OpenMP baseline
    \item Phù hợp cho production system với yêu cầu real-time
    \item Hệ thống đã có GPU NVIDIA và CUDA toolkit
\end{itemize}

\textbf{Thay đổi code:}
\begin{itemize}
    \item Loại bỏ OpenMP-only implementation và SIMD implementation
    \item Loại bỏ fallback mechanisms và enum \texttt{SobelMethod}
    \item Chỉ sử dụng CUDA cho Sobel filter
    \item Build bắt buộc phải có CUDA support
    \item Error nếu không có CUDA: \texttt{USE\_CUDA\_SOBEL must be defined}
\end{itemize}

\textbf{Lưu ý:} Nếu hệ thống không có GPU NVIDIA, code sẽ không build được. Có thể tạo branch riêng với fallback logic hoặc sử dụng các build scripts cũ nếu cần.

\subsection{Nhạy nhiễu}

Bộ lọc Sobel có thể nhạy cảm với nhiễu trong ảnh. Khi ảnh có nhiều nhiễu, Sobel có thể tạo ra nhiều biên giả (false edges), ảnh hưởng đến kết quả detection.

\textbf{Giải pháp:} Có thể kết hợp với Gaussian blur trước khi áp dụng Sobel để giảm nhiễu.

\subsection{Điều kiện ánh sáng xấu}

Với điều kiện ánh sáng rất tối hoặc quá sáng, Sobel có thể không hiệu quả. Model học sâu có thể xử lý tốt hơn trong các điều kiện này nếu được huấn luyện đúng cách.

\subsection{Tài nguyên phần cứng}

\textbf{GPU:} Phương pháp CUDA yêu cầu GPU NVIDIA, không phải hệ thống nào cũng có.

\textbf{CPU:} SIMD yêu cầu CPU hỗ trợ AVX2, một số CPU cũ có thể không hỗ trợ.

\textbf{Bộ nhớ:} Pipeline với nhiều frame buffer yêu cầu bộ nhớ đủ lớn, đặc biệt với video độ phân giải cao.

\subsection{Hạn chế khác}

\begin{itemize}
    \item Pipeline hiện tại chưa tối ưu batch inference cho model (xử lý từng frame một)
    \item Chưa có cơ chế adaptive quality (tự động điều chỉnh chất lượng theo FPS)
    \item Chưa hỗ trợ multi-GPU để tăng throughput hơn nữa
    \item Chưa triển khai CUDA streams để overlap computation và data transfer
    \item Chưa sử dụng shared memory trong CUDA kernel để tối ưu memory access
    \item Chưa có cơ chế work stealing cho thread pool
    \item Chưa triển khai lock-free data structures để giảm contention
\end{itemize}

\subsection{Các kỹ thuật đã triển khai}

Đề tài đã triển khai thành công các kỹ thuật song song hóa sau:

\textbf{Data Parallelism:}
\begin{itemize}
    \item \textbf{SIMD Vectorization:} Sử dụng AVX-256 intrinsics để xử lý 8 pixels cùng lúc trong Sobel filter
    \item \textbf{OpenMP:} Song song hóa theo dòng ảnh, kết hợp với SIMD để tạo song song hóa 2 tầng
    \item \textbf{Multi-ROI OCR Processing:} Xử lý nhiều biển số song song nếu detect được nhiều ROI trong một frame
\end{itemize}

\textbf{Task Parallelism:}
\begin{itemize}
    \item \textbf{Pipeline với 5 threads:} Tách Capture, Sobel, Detection, OCR, và Render thành các threads độc lập
    \item \textbf{Tách Detection và OCR:} Detection và OCR chạy trên các frame khác nhau, không block nhau
    \item \textbf{Thread-Safe Queues:} Sử dụng TSQueue với mutex và condition variable để truyền dữ liệu an toàn giữa các threads
\end{itemize}

\textbf{Kết hợp Data + Task Parallelism:}
\begin{itemize}
    \item Pipeline sử dụng cả Data Parallelism (SIMD, OpenMP) và Task Parallelism (5 threads độc lập)
    \item Mỗi thread có thể sử dụng Data Parallelism bên trong (ví dụ: Sobel thread dùng SIMD)
    \item Kết quả: Song song hóa đa tầng, tận dụng tối đa tài nguyên phần cứng
\end{itemize}

\chapter{KẾT LUẬN VÀ HƯỚNG PHÁT TRIỂN}

\section{Kết luận}

\subsection{Tổng kết kết quả đạt được}

Đề tài đã thành công trong việc:

\textbf{Triển khai pipeline song song:} Xây dựng hệ thống xử lý ảnh với 5 threads độc lập, tận dụng cả Data Parallelism (SIMD, OpenMP) và Task Parallelism (tách Detection/OCR).

\textbf{Tối ưu Sobel filter:} Đạt được speedup đáng kể:
\begin{itemize}
    \item SIMD: 3.79x so với scalar code
    \item CUDA: 14.47x so với scalar code, 3.82x so với SIMD
\end{itemize}

\textbf{Tích hợp model học sâu:} Kết hợp thành công YOLOv5 với pipeline tiền xử lý Sobel, tạo hệ thống nhận dạng biển số hoàn chỉnh.

\subsection{Mức cải thiện so với baseline}

So với pipeline không có tối ưu:
\begin{itemize}
    \item \textbf{Sobel processing:} Từ 7.144ms (scalar) xuống 0.494ms (CUDA) - cải thiện 14.47x
    \item \textbf{Throughput:} Từ 140 FPS (scalar) lên 2025.5 FPS (CUDA) cho Sobel filter
    \item \textbf{Pipeline latency:} Giảm đáng kể nhờ song song hóa các stage
\end{itemize}

\subsection{Đóng góp chính}

\begin{enumerate}
    \item Đề xuất và triển khai pipeline tiền xử lý song song với nhiều tầng tối ưu (Data + Task Parallelism)
    \item So sánh chi tiết các phương pháp song song hóa (scalar, SIMD, CUDA) với benchmark cụ thể
    \item Đánh giá ảnh hưởng của Sobel filter đến hiệu suất model học sâu
    \item Triển khai cơ chế fallback thông minh (CUDA → SIMD → OpenMP) để đảm bảo hoạt động trên mọi hệ thống
    \item Tách Detection và OCR thành 2 threads riêng để tăng throughput pipeline
    \item Cung cấp benchmark và code mẫu có thể tái sử dụng
    \item Quyết định sử dụng CUDA làm phương pháp chính dựa trên kết quả benchmark (14.47x speedup)
\end{enumerate}

\section{Hướng phát triển}

\subsection{OCR biển số}

\textbf{Cải thiện accuracy:} 
\begin{itemize}
    \item Fine-tune OCR model với dataset lớn hơn và đa dạng hơn
    \item Xử lý các trường hợp đặc biệt: biển số cũ, biển số nước ngoài
    \item Post-processing để sửa lỗi nhận dạng (spell checking, format validation)
\end{itemize}

\textbf{Tối ưu tốc độ:}
\begin{itemize}
    \item Batch inference cho nhiều ROI cùng lúc
    \item Quantization model để giảm kích thước và tăng tốc
    \item Sử dụng TensorRT cho NVIDIA GPU
\end{itemize}

\subsection{Real-time video}

\textbf{Video streaming:}
\begin{itemize}
    \item Hỗ trợ RTSP stream từ IP camera
    \item Xử lý video với frame rate cao (60 FPS+)
    \item Adaptive frame skipping để duy trì real-time
\end{itemize}

\textbf{Tracking:}
\begin{itemize}
    \item Triển khai object tracking để theo dõi biển số qua nhiều frame
    \item Giảm số lần chạy detection bằng cách sử dụng tracking
    \item Cải thiện accuracy bằng cách tích hợp thông tin từ nhiều frame
\end{itemize}

\subsection{Triển khai Edge AI}

\textbf{Optimization cho edge devices:}
\begin{itemize}
    \item Model quantization (INT8) để giảm kích thước và tăng tốc
    \item Model pruning để loại bỏ các tham số không cần thiết
    \item Knowledge distillation để tạo model nhỏ hơn nhưng vẫn giữ accuracy
\end{itemize}

\textbf{Hardware acceleration:}
\begin{itemize}
    \item Tận dụng NPU (Neural Processing Unit) trên các thiết bị edge
    \item Optimize cho ARM CPU với NEON SIMD
    \item Hỗ trợ các framework edge như TensorFlow Lite, ONNX Runtime Mobile
\end{itemize}

\subsection{Tối ưu GPU sâu hơn}

\textbf{CUDA streams:}
\begin{itemize}
    \item Sử dụng multiple CUDA streams để overlap computation và data transfer
    \item Pipeline parallelism trên GPU để xử lý nhiều frame cùng lúc
    \item Stream 1: Upload frame N+1 lên GPU
    \item Stream 2: Chạy Sobel cho frame N
    \item Stream 3: Download kết quả frame N-1 về CPU
    \item Ba operations chạy song song trên GPU, giảm idle time
\end{itemize}

\textbf{Memory optimization:}
\begin{itemize}
    \item Unified memory (\texttt{cudaMallocManaged}) để giảm overhead copy CPU-GPU
    \item Shared memory để cache các dòng ảnh được sử dụng nhiều lần trong Sobel kernel
    \item Memory pooling để tái sử dụng buffer, tránh allocate/free liên tục
    \item Tối ưu memory access pattern để tận dụng memory coalescing
\end{itemize}

\textbf{Multi-GPU:}
\begin{itemize}
    \item Phân phối workload cho nhiều GPU
    \item Một GPU cho detection, GPU khác cho OCR
    \item Load balancing giữa các GPU
    \item Round-robin hoặc dynamic load balancing dựa trên GPU utilization
\end{itemize}

\subsection{Các ý tưởng tối ưu hóa bổ sung}

\textbf{2D Block Decomposition:}
\begin{itemize}
    \item Chia ảnh thành các block 2D (ví dụ 64x64 pixels)
    \item Mỗi thread xử lý 1 block độc lập
    \item Sử dụng \texttt{\#pragma omp parallel for collapse(2)} để song song hóa 2 chiều
\end{itemize}

\textbf{Batch Inference:}
\begin{itemize}
    \item Gom nhiều frame lại thành batch [N, 3, H, W]
    \item Inference 1 lần cho cả batch → tăng throughput
    \item Đặc biệt hiệu quả với GPU
\end{itemize}

\textbf{Pre-processing Pipeline Song Song:}
\begin{itemize}
    \item Nhiều pre-processing chạy song song: resize, normalize, color space conversion, noise reduction
    \item Sử dụng \texttt{std::async} để chạy các task độc lập
\end{itemize}

\textbf{Work Stealing:}
\begin{itemize}
    \item Thread pool với work stealing
    \item Thread nào xong việc sẽ "ăn cắp" work từ thread khác
    \item Lock-free queue để giảm contention
\end{itemize}

\textbf{NUMA-aware Parallelism:}
\begin{itemize}
    \item Nếu có nhiều CPU sockets (NUMA)
    \item Bind threads vào CPU cores cụ thể
    \item Sử dụng \texttt{pthread\_setaffinity\_np} để tối ưu memory access
\end{itemize}

\subsection{Các hướng phát triển khác}

\textbf{Deep learning optimization:}
\begin{itemize}
    \item Thử nghiệm các kiến trúc model mới (YOLOv8, YOLOv9, DETR)
    \item Transfer learning với dataset lớn hơn
    \item Ensemble methods để tăng accuracy
\end{itemize}

\textbf{System integration:}
\begin{itemize}
    \item REST API để tích hợp với hệ thống khác
    \item Database để lưu trữ kết quả nhận dạng
    \item Dashboard để monitoring và quản lý
\end{itemize}

\textbf{Advanced features:}
\begin{itemize}
    \item Nhận dạng loại xe (ô tô, xe máy, xe tải)
    \item Phát hiện vi phạm (đỗ xe sai, quá tốc độ)
    \item Phân tích lưu lượng giao thông
\end{itemize}

\section{Lời cảm ơn}

Xin chân thành cảm ơn thầy/cô hướng dẫn và các bạn đã hỗ trợ trong quá trình thực hiện đề tài.

\appendix

\chapter{Mã nguồn quan trọng}

\section{Pipeline Architecture}

Kiến trúc pipeline với 5 threads và các queue thread-safe được triển khai trong \texttt{Pipeline.h} và \texttt{Pipeline.cpp}. Hệ thống sử dụng:
\begin{itemize}
    \item 5 threads độc lập: Capture, Sobel, Detection, OCR, Render
    \item 5 thread-safe queues (TSQueue) với buffer tối đa 5 frames mỗi queue
    \item FramePacket để đóng gói dữ liệu giữa các stages
    \item Atomic flag \texttt{running\_} để điều khiển dừng pipeline
\end{itemize}

\section{Sobel SIMD Implementation}

Implementation Sobel với AVX-256 được triển khai trong \texttt{SobelSIMD.cpp}, sử dụng intrinsics để xử lý 8 pixels cùng lúc. Code kết hợp:
\begin{itemize}
    \item AVX-256 intrinsics cho vectorization (8 pixels/cycle)
    \item OpenMP \texttt{\#pragma omp parallel for} để song song hóa theo dòng
    \item Scalar fallback cho các pixel còn lại ở cuối mỗi dòng
\end{itemize}

\section{CUDA Kernel}

CUDA kernel cho Sobel được triển khai trong \texttt{SobelCuda.cu}, với mỗi thread xử lý một pixel. Implementation bao gồm:
\begin{itemize}
    \item Kernel function \texttt{sobelKernel} với 2D thread mapping
    \item Block size 16x16 = 256 threads per block
    \item Grid size tự động tính toán để bao phủ toàn bộ ảnh
    \item Host code quản lý memory allocation, transfer, và kernel launch
\end{itemize}

\section{Cấu trúc dự án}

Dự án được tổ chức theo cấu trúc rõ ràng:

\textbf{Source code (\texttt{src/}):}
\begin{itemize}
    \item \texttt{main.cpp}: Entry point, khởi tạo Pipeline với models \texttt{bestDetect.onnx} và \texttt{bestOCR.onnx}
    \item \texttt{Pipeline.cpp}: Pipeline với 5 threads độc lập (Capture, Sobel, Detect, OCR, Render)
    \item \texttt{LPDetector.cpp}: Wrapper cho YOLOv5 detection model
    \item \texttt{LPOCR.cpp}: Wrapper cho YOLOv5 OCR model
    \item \texttt{SobelCuda.cu}: CUDA kernel cho Sobel filter (one-thread-per-pixel)
    \item \texttt{SobelSIMD.cpp}: SIMD implementation với AVX-256 (8 pixels/cycle)
\end{itemize}

\textbf{Headers (\texttt{include/}):}
\begin{itemize}
    \item \texttt{Pipeline.h}: Pipeline class với TSQueue, FramePacket, 5 threads
    \item \texttt{LPDetector.h}, \texttt{LPOCR.h}: Model wrapper headers
    \item \texttt{SobelCuda.h}, \texttt{SobelSIMD.h}: Sobel implementation headers
\end{itemize}

\textbf{Build scripts (\texttt{scripts/}):}
\begin{itemize}
    \item \texttt{build.sh}: Build với CUDA (chính), tự động detect GPU architecture
    \item \texttt{build\_simd.sh}: Build với SIMD + OpenMP (không CUDA)
    \item \texttt{build\_openmp.sh}: Build chỉ với OpenMP (scalar)
    \item \texttt{benchmark.sh}: Script tự động benchmark cả 3 phương pháp
\end{itemize}

\textbf{Models (\texttt{models/}):}
\begin{itemize}
    \item \texttt{bestDetect.onnx}, \texttt{bestOCR.onnx}: Models ONNX (được sử dụng)
    \item \texttt{bestDetect.pt}, \texttt{bestOCR.pt}: Models PyTorch gốc
    \item \texttt{convert.py}: Script convert từ .pt sang .onnx
\end{itemize}

\textbf{Output binaries:}
\begin{itemize}
    \item \texttt{lp\_main}: Binary với CUDA support (từ \texttt{build.sh})
    \item \texttt{lp\_main\_simd}: Binary với SIMD support (từ \texttt{build\_simd.sh})
    \item \texttt{lp\_main\_openmp}: Binary với OpenMP only (từ \texttt{build\_openmp.sh})
\end{itemize}

\chapter{Bảng ký hiệu và thuật ngữ}

\begin{itemize}
    \item \textbf{FPS:} Frames Per Second - Số khung hình mỗi giây
    \item \textbf{Latency:} Độ trễ - Thời gian xử lý từ đầu đến cuối
    \item \textbf{SIMD:} Single Instruction Multiple Data - Một lệnh xử lý nhiều dữ liệu
    \item \textbf{AVX:} Advanced Vector Extensions - Mở rộng vector của Intel
    \item \textbf{CUDA:} Compute Unified Device Architecture - Kiến trúc tính toán của NVIDIA
    \item \textbf{ONNX:} Open Neural Network Exchange - Định dạng trao đổi mô hình neural network
    \item \textbf{YOLO:} You Only Look Once - Kiến trúc object detection
    \item \textbf{NMS:} Non-Maximum Suppression - Loại bỏ detection trùng lặp
    \item \textbf{ROI:} Region of Interest - Vùng quan tâm
    \item \textbf{OCR:} Optical Character Recognition - Nhận dạng ký tự quang học
\end{itemize}

\end{document}

